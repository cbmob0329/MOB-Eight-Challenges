<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>MOB balloon</title>
<meta name="theme-color" content="#0a0b0e">
<style>
  :root{ --fg:#eaf3ff; --dim:#9fb0c9; --accent:#13c4ff; --danger:#ff4d6d; }
  html{height:-webkit-fill-available}
  body{
    margin:0; background:#000; color:var(--fg);
    height:100vh; height:-webkit-fill-available; overflow:hidden;
    font-family:"Hiragino Sans","Yu Gothic",system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    -webkit-tap-highlight-color:transparent;
  }
  #wrap{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto}
  header,footer{
    padding:8px 12px; background:rgba(8,10,16,.75); backdrop-filter:blur(6px);
    display:flex; align-items:center; justify-content:space-between; gap:8px; z-index:10
  }
  header .ttl{font-weight:800; letter-spacing:.03em}
  header .ttl b{color:#ff4d6d}
  header .info{font-size:12px; color:var(--dim)}
  #game{position:relative; overflow:hidden}
  canvas{position:absolute; inset:0; width:100%; height:100%; image-rendering:pixelated; touch-action:none}
  .overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:8}
  .count{font-weight:900; font-size:clamp(36px,14vw,120px); text-shadow:0 4px 24px rgba(0,0,0,.6)}
  .msgbox{position:absolute; inset-inline:0; bottom:18%; display:flex; justify-content:center; pointer-events:none}
  .chip{background:rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.15); color:#cfe5ff; padding:6px 10px; border-radius:12px; font-size:13px}
  /* On-screen D-Pad */
  #dpad{position:absolute; left:16px; bottom:16px; width:168px; height:168px; z-index:12; touch-action:none; display:grid; grid-template-columns:56px 56px 56px; grid-template-rows:56px 56px 56px; gap:0;}
  .padbtn{
    background:#161d30; border:1px solid #2d3a5b; color:#cfe5ff; font-weight:800; border-radius:12px;
    display:flex; align-items:center; justify-content:center; user-select:none;
    box-shadow:0 8px 18px rgba(0,0,0,.3);
  }
  .padbtn:active{transform:translateY(1px)}
  .padbtn.invis{background:transparent; border:none; box-shadow:none}
  #btns{position:absolute; right:16px; bottom:16px; display:flex; flex-direction:column; gap:10px; z-index:12}
  .btn{appearance:none; border:none; border-radius:12px; padding:10px 14px; font-weight:800; background:#162035; color:#cfe5ff; border:1px solid #33436a; box-shadow:0 8px 20px rgba(0,0,0,.3)}
  .btn:active{transform:translateY(1px)}
  .btn.red{background:#34121a; color:#ffd1d9; border-color:#612331}
  footer{font-size:12px; color:var(--dim)}
  .dot{width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:6px; background:#ff4d6d}
  .fast{color:#ffe08a}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="ttl">MOB <b>balloon</b></div>
    <div class="info">
      <span id="leftInfo">残り: 8</span> ｜ <span id="distInfo">距離: 0 m</span> ｜ <span id="speedInfo">x1</span>
    </div>
  </header>

  <div id="game" role="application" aria-label="MOB balloon">
    <canvas id="cv"></canvas>
    <div class="overlay"><div id="count" class="count"></div></div>
    <div class="msgbox"><div class="chip">下から上へ。青い部分＝壁。カラスに当たると破裂。</div></div>

    <!-- 十字キー（スマホ用） -->
    <div id="dpad" aria-hidden="false">
      <div class="padbtn invis"></div>
      <div id="up" class="padbtn">▲</div>
      <div class="padbtn invis"></div>
      <div id="left" class="padbtn">◀</div>
      <div class="padbtn invis"></div>
      <div id="right" class="padbtn">▶</div>
      <div class="padbtn invis"></div>
      <div id="down" class="padbtn">▼</div>
      <div class="padbtn invis"></div>
    </div>

    <div id="btns">
      <button id="btnStart" class="btn">START</button>
      <button id="btnRetry" class="btn red" style="display:none">RETRY</button>
    </div>
  </div>

  <footer>
    <div><span class="dot"></span>あなた（赤）／ CPU x7 <span id="statusNote"></span></div>
    <div>© MOB ARTIST</div>
  </footer>
</div>

<script>
(()=>{
// ===== Canvas / Resize =====
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d',{alpha:true});
let W=0,H=0,DPR=1;
function resize(){
  DPR = Math.max(1, Math.min(3, window.devicePixelRatio||1));
  W = Math.floor(cv.clientWidth*DPR);
  H = Math.floor(cv.clientHeight*DPR);
  cv.width=W; cv.height=H;
  ctx.imageSmoothingEnabled=false;
  setSizes();
  buildTileAndMask(); // 再スケール＋壁再解析
}
window.addEventListener('resize', resize);

// ===== Assets =====
const BG = new Image(); BG.src='krace.png';
const K1 = new Image(); K1.src='karasu1.png';
const K2 = new Image(); K2.src='karasu2.png';
const balloonFiles = {
  red: 'Redb.png', blue: 'Blueb.png', green:'Greenb.png', purple:'murab.png',
  orange:'Orangeb.png', pink:'Pinkb.png', black:'Blackb.png', yellow:'yellowb.png'
};
const BIMG = {};
for(const k in balloonFiles){ const im=new Image(); im.src = balloonFiles[k]; BIMG[k]=im; }

// ===== 背景タイル化 & 壁マスク（2D） =====
let tileCanvas=null, tileCtx=null, tileH=0, mask=null, bgReady=false;
function isBlueish(r,g,b){ return (b>135 && b>r+20 && b>g+20); } // 青判定
function buildTileAndMask(){
  if(!W || !H) return;
  if(!tileCanvas){ tileCanvas=document.createElement('canvas'); tileCtx=tileCanvas.getContext('2d',{willReadFrequently:true}); }
  bgReady=false; mask=null;
  if(BG.complete && BG.naturalWidth){
    const r = W / BG.naturalWidth;               // 幅合わせ（横は画面にフィット）
    tileH = Math.max(1, Math.floor(BG.naturalHeight * r)); // 縦は比率で
    tileCanvas.width = W; tileCanvas.height = tileH;
    tileCtx.imageSmoothingEnabled=false;
    tileCtx.clearRect(0,0,W,tileH);
    tileCtx.drawImage(BG, 0,0,BG.naturalWidth,BG.naturalHeight, 0,0, W, tileH);
    // 2D壁マスクを構築（各ピクセルごとに壁=1/通行=0）
    try{
      const data = tileCtx.getImageData(0,0,W,tileH).data;
      mask = new Uint8Array(W*tileH);
      for(let y=0;y<tileH;y++){
        for(let x=0;x<W;x++){
          const i=(y*W+x)*4;
          const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
          mask[y*W+x] = (a>=10 && isBlueish(r,g,b)) ? 1 : 0;
        }
      }
      bgReady=true;
    }catch(e){
      // 読めない場合はマスク無し（左右端だけ壁）
      mask=null; bgReady=false;
    }
  }else{
    tileCanvas.width=W; tileCanvas.height=H; tileCtx.clearRect(0,0,W,H);
    mask=null; bgReady=false;
  }
}
// world座標→壁判定（タイルは上から下へ並ぶ。world y は上向き正）
function isWallWorld(x,y){
  const xi = Math.max(0, Math.min(W-1, Math.floor(x)));
  if(!mask){ // フォールバック：左右端だけ壁
    const m = 10*DPR;
    return (xi<m || xi>W-m);
  }
  // world y をタイルyにマッピング（下が0ではなく、タイルの下端=tileH-1）
  let yi = (tileH - 1) - (Math.floor(y) % tileH);
  if(yi<0) yi += tileH * (1 + Math.floor((-yi)/tileH));
  yi %= tileH;
  return mask[yi*W + xi] === 1;
}
function circleHitWall(x,y,r){
  const a=0.707;
  const pts = [
    [x+r,y],[x-r,y],[x,y+r],[x,y-r],
    [x+r*a,y+r*a],[x-r*a,y+r*a],[x+r*a,y-r*a],[x-r*a,y-r*a]
  ];
  for(const [px,py] of pts){ if(isWallWorld(px,py)) return true; }
  return false;
}
// 指定yで通行可能な水平区間を配列で返す [[L,R],...]
function openSegmentsAtY(y){
  const segs=[]; let s=null;
  for(let x=0;x<W;x++){
    if(!isWallWorld(x,y)){ if(s===null) s=x; }
    else if(s!==null){ segs.push([s,x-1]); s=null; }
  }
  if(s!==null) segs.push([s,W-1]);
  return segs;
}

// ===== Game parameters =====
const STATE={TITLE:0,COUNT:1,PLAY:2,FAST:3,RESULT:4};
let state=STATE.TITLE;
let R=18, SPEED=160, MAXS=320, FRICTION=0.985, BOUNCE=0.55;
let elapsed=0, camY=0;
function setSizes(){
  const base=Math.min(W,H);
  R = Math.round(base*0.035);
  SPEED = base*0.18;
  MAXS = base*0.33;
}

// ===== Entities =====
const players=[];
const cpuKeys=['blue','green','purple','orange','pink','black','yellow'];
function makeBalloon(id,isYou,key,x,y){
  return {id,you:isYou,key,img:BIMG[key],alive:true,x,y,vx:0,vy:0,r:R,maxY:y,aiT:0,pop:0};
}
// スタート：一番下から少し上。壁の内側の最長帯に等間隔で横一列（並び順はランダム）
function initPlayers(){
  players.length=0;
  let yStart = R*2;
  // yStartが壁帯なら少し上げる（最大数回）
  for(let tries=0; tries<10 && openSegmentsAtY(yStart).length===0; tries++) yStart += R*0.8;

  let segs = openSegmentsAtY(yStart);
  if(!segs.length){ // 万一失敗したら画面中央で
    segs = [[Math.floor(W*0.18), Math.floor(W*0.82)]];
  }
  let best = segs.reduce((m,a)=> (a[1]-a[0]>m[1]-m[0]?a:m), segs[0]);
  const margin = Math.max(R*2, 14*DPR);
  const L = Math.max(best[0]+margin, margin);
  const Rg = Math.min(best[1]-margin, W-margin);
  const slots=8;
  const xs = [];
  for(let i=0;i<slots;i++) xs.push(Math.round(L + (i+1)*(Rg-L)/(slots+1)));
  for(let i=xs.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [xs[i],xs[j]]=[xs[j],xs[i]]; }

  players.push(makeBalloon(0,true,'red', xs[0], yStart));
  for(let i=1;i<8;i++){
    players.push(makeBalloon(i,false, cpuKeys[(i-1)%cpuKeys.length], xs[i], yStart));
  }
}

// カラス：密集防止（ポアソン風の最小距離制約 + 壁内側スポーン）
const crows=[];
function crowMinDist(){ return 120*DPR; }
function spawnCrow(){
  const w = Math.round(56*DPR), h=Math.round(38*DPR);
  const dir = Math.random()<0.5? -1 : 1;
  // 画面の少し上〜だいぶ上に散布
  const yMin = camY + H*0.4, yMax = camY + H*1.6;
  let placed=false, tries=0;
  while(!placed && tries<30){
    tries++;
    const y = yMin + Math.random()*(yMax-yMin);
    // このyで十分広い通行帯を探す（幅>= w*1.8）
    const segs=openSegmentsAtY(y).filter(s=> (s[1]-s[0]) >= w*1.8);
    if(!segs.length) continue;
    const seg = segs[Math.floor(Math.random()*segs.length)];
    const margin = Math.max(10*DPR, w*0.5);
    const x = Math.round(seg[0]+margin + Math.random()*Math.max(1,(seg[1]-margin) - (seg[0]+margin)));
    // 既存カラスと最小距離
    let ok=true;
    for(const k of crows){
      if(!k.alive) continue;
      const dx=k.x - x, dy=(k.y - y), d2=dx*dx+dy*dy;
      if(d2 < crowMinDist()*crowMinDist()){ ok=false; break; }
    }
    if(!ok) continue;
    crows.push({x: dir<0? x+w : x-w, y, w, h, dir, sp: 70 + Math.random()*60, alive:true});
    placed=true;
  }
}
function wantCrowCount(){
  // 初期1→じわじわ増えて最大6
  return Math.min(6, 1 + Math.floor(elapsed/14));
}

// ===== Input（十字キー + 物理キーボード）=====
const dpad = {up:false,down:false,left:false,right:false};
function bindPad(id, key){
  const el = document.getElementById(id);
  const set = (v)=>{ dpad[key]=v; };
  const on = (e)=>{ e.preventDefault(); set(true); };
  const off= (e)=>{ e.preventDefault(); set(false); };
  el.addEventListener('pointerdown', on);
  el.addEventListener('pointerup', off);
  el.addEventListener('pointerleave', off);
  el.addEventListener('pointercancel', off);
  el.addEventListener('touchstart', on, {passive:false});
  el.addEventListener('touchend', off);
}
bindPad('up','up'); bindPad('down','down'); bindPad('left','left'); bindPad('right','right');

const keys={}; window.addEventListener('keydown',e=>{ keys[e.key.toLowerCase()]=true; });
window.addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });
function inputVec(){
  let x=0,y=0;
  if(dpad.left || keys['arrowleft'] || keys['a']) x-=1;
  if(dpad.right|| keys['arrowright']|| keys['d']) x+=1;
  if(dpad.up   || keys['arrowup']   || keys['w']) y+=1;    // 上へ+Y
  if(dpad.down || keys['arrowdown'] || keys['s']) y-=1;
  if(x||y){ const l=Math.hypot(x,y)||1; x/=l; y/=l; }
  return {x,y};
}

// ===== UI & State =====
const STATE_TXT={FAST:'<span class="fast">FAST FORWARD（プレイヤー脱落）</span>'};
const btnStart=document.getElementById('btnStart');
const btnRetry=document.getElementById('btnRetry');
const countEl=document.getElementById('count');
const leftInfo=document.getElementById('leftInfo');
const distInfo=document.getElementById('distInfo');
const speedInfo=document.getElementById('speedInfo');
const statusNote=document.getElementById('statusNote');
let speedMul=1, player=null, startY=0;

function resetGame(){
  state=STATE.TITLE; elapsed=0; speedMul=1; statusNote.textContent='';
  crows.length=0;
  initPlayers();
  player = players[0];
  startY = player.y;
  camY = 0;
  btnStart.style.display=''; btnRetry.style.display='none';
  countEl.textContent='';
  leftInfo.textContent='残り: 8'; distInfo.textContent='距離: 0 m'; speedInfo.textContent='x1';
}
function startCountdown(){
  state=STATE.COUNT; btnStart.style.display='none';
  let n=3; countEl.textContent='3';
  const step=()=>{ if(n===0){ countEl.textContent='GO'; setTimeout(()=>{countEl.textContent=''; startPlay();},500); return;} countEl.textContent=String(n); n--; setTimeout(step,650); };
  setTimeout(step,650);
}
function startPlay(){
  state=STATE.PLAY; elapsed=0; speedMul=1;
  while(crows.length<wantCrowCount()) spawnCrow();
}
function setFast(){
  if(state===STATE.PLAY){ state=STATE.FAST; speedMul=3; speedInfo.textContent='x3'; statusNote.innerHTML=STATE_TXT.FAST; }
}
function finishGame(){ state=STATE.RESULT; btnRetry.style.display=''; statusNote.textContent='レース終了'; }
btnStart.addEventListener('click', startCountdown);
btnRetry.addEventListener('click', resetGame);

// ===== CPU AI（壁クリアランス + カラス回避 + 分離 + 上方向）=====
function clearanceLR(x,y,limit){
  // 左右方向に壁までの距離を測る（最大limit）
  let L=0,Rd=0;
  for(let dx=1; dx<=limit; dx++){
    if(!L && isWallWorld(x-dx,y)) L=dx;
    if(!Rd && isWallWorld(x+dx,y)) Rd=dx;
    if(L && Rd) break;
  }
  return {left: L||limit+1, right: Rd||limit+1};
}

// ===== Physics / AI / Update =====
function update(dt){
  if(state===STATE.TITLE || state===STATE.COUNT || state===STATE.RESULT) return;
  const sdt = dt * (state===STATE.FAST? 3:1);
  elapsed += sdt;

  // プレイヤー入力（上向きが正）
  if(player.alive){
    const v = inputVec();
    const acc=SPEED*0.9;
    player.vx += v.x*acc*dt;
    player.vy += v.y*acc*dt;
  }

  // CPU：ステアリング合成
  for(const p of players){
    if(p.you || !p.alive) continue;
    let ax=0, ay=0;

    // 1) 目標＝上方向
    ay += 1.0;

    // 2) 壁クリアランス：広い方へ寄る
    const clr = clearanceLR(p.x, p.y, Math.round(140*DPR));
    const wallPush = (clr.right - clr.left); // 右が広ければ+、左が広ければ-
    ax += wallPush * 0.006; // 微調整

    // 3) カラス回避（予測位置）
    let nx=0, ny=0, count=0;
    for(const k of crows){
      if(!k.alive) continue;
      const predX = k.x + k.dir*k.sp*0.6; // 先読み
      const predY = k.y;
      const dx = p.x - predX, dy = p.y - predY;
      const d2 = dx*dx + dy*dy;
      if(d2 < (220*DPR)*(220*DPR)){
        const d=Math.sqrt(d2)||1;
        nx += dx/d; ny += dy/d; count++;
      }
    }
    if(count){ ax += (nx/count)*0.9; ay += (ny/count)*0.9; }

    // 4) 他CPUと分離（密集回避）
    nx=0; ny=0; count=0;
    for(const q of players){
      if(q===p || !q.alive) continue;
      const dx=p.x-q.x, dy=p.y-q.y, d2=dx*dx+dy*dy;
      const minD=(p.r+q.r)*2.4;
      if(d2 < minD*minD){
        const d=Math.sqrt(d2)||1; nx += dx/d; ny += dy/d; count++;
      }
    }
    if(count){ ax += (nx/count)*0.6; ay += (ny/count)*0.6; }

    // ノイズ少々
    ax += Math.sin((elapsed*0.8 + p.id))*0.15;

    const acc=SPEED*0.75;
    p.vx += ax*acc*dt; p.vy += ay*acc*dt;
  }

  // 摩擦・速度制限・移動＆壁バウンド
  for(const p of players){
    if(!p.alive) continue;
    p.vx *= FRICTION; p.vy *= FRICTION;
    const v = Math.hypot(p.vx,p.vy), LIM=MAXS; if(v>LIM){ p.vx=p.vx/v*LIM; p.vy=p.vy/v*LIM; }

    let nx=p.x + p.vx*dt, ny=p.y + p.vy*dt;
    if(circleHitWall(nx, p.y, p.r)){ p.vx*=-BOUNCE; nx=p.x + p.vx*dt; }
    if(circleHitWall(p.x, ny, p.r)){ p.vy*=-BOUNCE; ny=p.y + p.vy*dt; }
    p.x=nx; p.y=ny;
    if(p.y>p.maxY) p.maxY=p.y;
  }

  // 風船反発
  for(let i=0;i<players.length;i++){
    const a=players[i]; if(!a.alive) continue;
    for(let j=i+1;j<players.length;j++){
      const b=players[j]; if(!b.alive) continue;
      const dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy), min=a.r+b.r;
      if(d>0 && d<min){
        const nx=dx/d, ny=dy/d, push=(min-d)*0.6;
        a.x-=nx*push*0.5; a.y-=ny*push*0.5;
        b.x+=nx*push*0.5; b.y+=ny*push*0.5;
        const rvx=b.vx-a.vx, rvy=b.vy-a.vy, rel=rvx*nx+rvy*ny;
        if(rel>0){ const imp=rel*0.5; a.vx+=nx*imp*BOUNCE; a.vy+=ny*imp*BOUNCE; b.vx-=nx*imp*BOUNCE; b.vy-=ny*imp*BOUNCE; }
      }
    }
  }

  // カラス：密集防止・数は控えめで散らす
  const want=wantCrowCount();
  while(crows.filter(k=>k.alive).length<want) spawnCrow();
  for(const k of crows){
    if(!k.alive) continue;
    const spMul = 1 + Math.min(1.2, elapsed/50); // 緩やかに加速
    k.x += k.dir * k.sp * spMul * dt;

    // 壁で反転（はみ出しに強い）
    if(isWallWorld(k.x - 2, k.y) && k.dir<0) k.dir=1;
    if(isWallWorld(k.x + k.w + 2, k.y) && k.dir>0) k.dir=-1;

    // 近すぎるカラス同士は少し拡散（横方向）
    for(const m of crows){
      if(m===k || !m.alive) continue;
      const dx=k.x - m.x, dy=k.y - m.y, d2=dx*dx+dy*dy;
      if(d2 < (crowMinDist()*crowMinDist()*0.7)){
        const s=(1/Math.sqrt(d2+1e-3))*30*dt;
        k.x += dx*s; m.x -= dx*s;
      }
    }

    // 画面より大きく下に去ったら消す
    if(k.y < camY - H*0.9) k.alive=false;
  }

  // カラス衝突
  for(const p of players){
    if(!p.alive) continue;
    for(const k of crows){
      if(!k.alive) continue;
      const rx = Math.max(k.x, Math.min(p.x, k.x+k.w));
      const ry = Math.max(k.y, Math.min(p.y, k.y+k.h));
      const d2 = (p.x-rx)*(p.x-rx) + (p.y-ry)*(p.y-ry);
      if(d2 < (p.r*p.r*0.75)){
        p.alive=false; p.pop=0;
        if(p===player) setFast();
        break;
      }
    }
  }

  // 情報
  const distM = Math.max(0, (player.maxY - startY)/(40*DPR));
  distInfo.textContent = '距離: ' + distM.toFixed(1) + ' m';
  leftInfo.textContent = '残り: ' + players.filter(p=>p.alive).length;

  // カメラ追従（自分の少し上）
  const target = Math.max(0, player.y - H*0.45);
  camY += (target - camY) * 0.12;

  if(players.filter(p=>p.alive).length<=1 && (state===STATE.PLAY || state===STATE.FAST)) finishGame();
}

// ===== Rendering =====
function drawBackground(){
  if(tileCanvas && tileH>0){
    const off = - (camY % tileH);
    for(let y=off; y<H; y+=tileH){
      ctx.drawImage(tileCanvas, 0, Math.floor(y));
    }
  }else{
    const g=ctx.createLinearGradient(0,H,0,0);
    g.addColorStop(0,'#0b1020'); g.addColorStop(1,'#1a2338');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#163a7a'; ctx.fillRect(0,0,10*DPR,H); ctx.fillRect(W-10*DPR,0,10*DPR,H);
  }
}
function worldToScreenY(y){ return Math.floor(H - (y - camY)); }

function draw(){
  drawBackground();

  // カラス
  for(const k of crows){
    if(!k.alive) continue;
    const sy = worldToScreenY(k.y);
    const img = k.dir<0 ? K1 : K2;
    if(img && img.complete && img.naturalWidth){
      ctx.drawImage(img, Math.floor(k.x), Math.floor(sy - k.h), Math.floor(k.w), Math.floor(k.h));
    }else{
      ctx.fillStyle='#222'; ctx.fillRect(k.x, sy-k.h, k.w, k.h);
      ctx.fillStyle='#f90'; ctx.fillRect(k.x + (k.dir<0? k.w*0.7: k.w*0.1), sy-k.h*0.65, k.w*0.2, k.h*0.2);
    }
  }

  // 風船＆破裂演出
  for(const p of players){
    const sy = worldToScreenY(p.y);
    if(!p.alive){
      if(p.pop<1){
        p.pop += 0.03 * (state===STATE.FAST?3:1);
        const a = Math.max(0, 1-p.pop), s=1+p.pop*1.2;
        ctx.save(); ctx.globalAlpha=a; ctx.translate(p.x, sy); ctx.scale(s,s);
        drawBalloon(p,0,0,true); ctx.restore();
      }
      continue;
    }
    drawBalloon(p, p.x, sy, false);
  }
}
function drawBalloon(p, sx, sy, isPop){
  // ヒモ
  ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.lineWidth=Math.max(1, 2*DPR);
  ctx.beginPath(); ctx.moveTo(sx, sy+p.r*0.6); ctx.lineTo(sx, sy+p.r*1.4); ctx.stroke();

  const img = p.img, size = Math.round(p.r*2.2);
  if(img && img.complete && img.naturalWidth){
    ctx.drawImage(img, Math.floor(sx-size/2), Math.floor(sy-size/2), size, size);
  }else{
    ctx.fillStyle = p.you ? '#ff4d6d' : '#7fd0ff';
    ctx.beginPath(); ctx.arc(sx, sy, p.r, 0, Math.PI*2); ctx.fill();
  }
  if(p.you){
    ctx.fillStyle='#111'; ctx.font=`${Math.round(p.r*0.9)}px sans-serif`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('M', sx, sy);
  }
}

// ===== Main loop =====
let last=0;
function loop(t){
  if(!last) last=t;
  const dt = Math.min(0.033, (t-last)/1000); last=t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// ===== Boot =====
resize();
buildTileAndMask();
initPlayers();
let speedInfo=document.getElementById('speedInfo');
function setFast(){ if(state===STATE.PLAY){ state=STATE.FAST; speedInfo.textContent='x3'; statusNote.innerHTML='<span class="fast">FAST FORWARD（プレイヤー脱落）</span>'; } }
requestAnimationFrame(loop);

// Buttons
document.getElementById('btnStart').addEventListener('click', startCountdown);
document.getElementById('btnRetry').addEventListener('click', resetGame);
})();
</script>
</body>
</html>
