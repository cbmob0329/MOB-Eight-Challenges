<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
<title>MOB balloon</title>
<meta name="theme-color" content="#0a0b0e" />
<style>
  :root{ --fg:#eaf3ff; --dim:#9fb0c9; --accent:#13c4ff; --danger:#ff4d6d; }
  html{height:-webkit-fill-available}
  body{
    margin:0; background:#000; color:var(--fg);
    height:100vh; height:-webkit-fill-available; overflow:hidden;
    font-family:"Hiragino Sans","Yu Gothic",system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    -webkit-tap-highlight-color:transparent;
  }
  #wrap{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto}
  header, footer{
    padding:8px 12px; background:rgba(10,12,18,.75); backdrop-filter:blur(6px);
    display:flex; align-items:center; justify-content:space-between; gap:8px; z-index:10
  }
  header .ttl{font-weight:800; letter-spacing:.03em}
  header .ttl b{color:#ff4d6d}
  header .info{font-size:12px; color:var(--dim)}
  #game{position:relative; overflow:hidden}
  canvas{position:absolute; inset:0; width:100%; height:100%; image-rendering:pixelated; touch-action:none}

  .overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:8}
  .count{font-weight:900; font-size:clamp(36px,14vw,120px); text-shadow:0 4px 24px rgba(0,0,0,.6)}
  .msgbox{position:absolute; inset-inline:0; bottom:18%; display:flex; justify-content:center; pointer-events:none}
  .chip{background:rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.15); color:#cfe5ff; padding:6px 10px; border-radius:12px; font-size:13px}

  /* ===== 十字キー（見た目が“+”の一体型） ===== */
  #cross{
    position:absolute; left:16px; bottom:16px; width:168px; height:168px; z-index:12; touch-action:none;
    display:grid; grid-template-columns:56px 56px 56px; grid-template-rows:56px 56px 56px;
  }
  #cross .hit{background:transparent}
  #cross .key{
    background:#162033; border:1px solid #2d3d60; color:#cfe5ff; font-weight:800;
    display:flex; align-items:center; justify-content:center; user-select:none; border-radius:12px;
    box-shadow:0 8px 18px rgba(0,0,0,.32);
  }
  #cross:before{
    content:""; position:absolute; inset:0;
    background:
      linear-gradient(#1a2540,#0f1730);
    clip-path: polygon(33% 0, 66% 0, 66% 33%, 100% 33%, 100% 66%, 66% 66%, 66% 100%, 33% 100%, 33% 66%, 0 66%, 0 33%, 33% 33%);
    border-radius:18px; border:1px solid #2d3d60;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.05);
    z-index:-1;
  }
  .key:active{transform:translateY(1px)}
  .key.invis{background:transparent; border:none; box-shadow:none}

  #btns{position:absolute; right:16px; bottom:16px; display:flex; flex-direction:column; gap:10px; z-index:12}
  .btn{appearance:none; border:none; border-radius:12px; padding:10px 14px; font-weight:800; background:#162035; color:#cfe5ff; border:1px solid #33436a; box-shadow:0 8px 20px rgba(0,0,0,.3)}
  .btn:active{transform:translateY(1px)}
  .btn.red{background:#34121a; color:#ffd1d9; border-color:#612331}
  footer{font-size:12px; color:var(--dim)}
  .dot{width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:6px; background:#ff4d6d}
  .fast{color:#ffe08a}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="ttl">MOB <b>balloon</b></div>
    <div class="info"><span id="leftInfo">残り: 8</span> ｜ <span id="distInfo">距離: 0 m</span> ｜ <span id="speedInfo">x1</span></div>
  </header>

  <div id="game" role="application" aria-label="MOB balloon">
    <canvas id="cv"></canvas>
    <div class="overlay"><div id="count" class="count"></div></div>
    <div class="msgbox"><div class="chip">下→上。青＝壁。カラスは散らして出現。</div></div>

    <!-- 十字キー：見た目は“+”だが、上下左右4領域のヒットを持つ -->
    <div id="cross" aria-hidden="false">
      <div class="hit"></div>          <div id="up"    class="key">▲</div> <div class="hit"></div>
      <div id="left"  class="key">◀</div><div class="key invis"></div>     <div id="right" class="key">▶</div>
      <div class="hit"></div>          <div id="down"  class="key">▼</div> <div class="hit"></div>
    </div>

    <div id="btns">
      <button id="btnStart" class="btn">START</button>
      <button id="btnRetry" class="btn red" style="display:none">RETRY</button>
    </div>
  </div>

  <footer>
    <div><span class="dot"></span>あなた（赤）／ CPU x7 <span id="statusNote"></span></div>
    <div>© MOB ARTIST</div>
  </footer>
</div>

<script>
(()=>{
/* =================== 基本セットアップ =================== */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d',{alpha:true});
let W=0,H=0,DPR=1;
function resize(){
  DPR = Math.max(1, Math.min(3, window.devicePixelRatio||1));
  W = Math.floor(cv.clientWidth*DPR);
  H = Math.floor(cv.clientHeight*DPR);
  cv.width=W; cv.height=H;
  ctx.imageSmoothingEnabled=false;
  setSizes();
  buildTileAndMask();  // 壁マスク再構築
}
window.addEventListener('resize', resize);

/* =================== アセット =================== */
const BG = new Image(); BG.crossOrigin="anonymous"; BG.src='krace.png';
const K1 = new Image(); K1.crossOrigin="anonymous"; K1.src='karasu1.png';
const K2 = new Image(); K2.crossOrigin="anonymous"; K2.src='karasu2.png';
const balloonFiles = {
  red: 'Redb.png', blue: 'Blueb.png', green:'Greenb.png', purple:'murab.png',
  orange:'Orangeb.png', pink:'Pinkb.png', black:'Blackb.png', yellow:'yellowb.png'
};
const BIMG={}; for(const k in balloonFiles){ const im=new Image(); im.crossOrigin="anonymous"; im.src=balloonFiles[k]; BIMG[k]=im; }

/* =================== 背景タイル & 壁マスク ===================
   - 画像を幅Wに合わせて拡大縮小（縦は比率）
   - ピクセルごとに「青い」なら1（壁）/ 0（通行）
   - 列方向に軽い膨張処理（壁を太らせて見逃し防止）
   - 行単位の“通行セグメント表”も作成（CPUの経路判断に使用）
============================================================= */
let tileCanvas=null,tileCtx=null,tileH=0,mask=null,bgReady=false,segTable=null;
function isBlueish(r,g,b){
  const B=b, R=r, G=g;
  return (B >= 120 && B - Math.max(R,G) >= 18); // しきい値やや緩め
}
function buildTileAndMask(){
  if(!W || !H) return;
  if(!tileCanvas){ tileCanvas=document.createElement('canvas'); tileCtx=tileCanvas.getContext('2d',{willReadFrequently:true}); }
  bgReady=false; mask=null; segTable=null;
  if(BG.complete && BG.naturalWidth){
    const r = W / BG.naturalWidth;            // 画面幅にフィット
    tileH = Math.max(1, Math.floor(BG.naturalHeight * r));
    tileCanvas.width=W; tileCanvas.height=tileH;
    tileCtx.imageSmoothingEnabled=false;
    tileCtx.clearRect(0,0,W,tileH);
    tileCtx.drawImage(BG, 0,0,BG.naturalWidth,BG.naturalHeight, 0,0, W, tileH);

    try{
      const data = tileCtx.getImageData(0,0,W,tileH).data;
      mask = new Uint8Array(W*tileH);
      // 初期判定
      for(let y=0;y<tileH;y++){
        for(let x=0;x<W;x++){
          const i=(y*W+x)*4; const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
          mask[y*W+x] = (a>=10 && isBlueish(r,g,b)) ? 1 : 0;
        }
      }
      // 列方向の軽い膨張（壁を太らせる）
      const dil = new Uint8Array(mask.length);
      for(let y=0;y<tileH;y++){
        for(let x=0;x<W;x++){
          if(mask[y*W+x]){ dil[y*W+x]=1;
            if(x>0) dil[y*W+x-1]=1;
            if(x<W-1) dil[y*W+x+1]=1;
          }
        }
      }
      mask = dil;

      // 行ごとの通行セグメント表
      segTable = new Array(tileH);
      for(let y=0;y<tileH;y++){
        const segs=[]; let s=null;
        for(let x=0;x<W;x++){
          if(mask[y*W+x]===0){ if(s===null) s=x; }
          else if(s!==null){ segs.push([s,x-1]); s=null; }
        }
        if(s!==null) segs.push([s,W-1]);
        segTable[y]=segs;
      }
      bgReady=true;
    }catch(e){ bgReady=false; mask=null; segTable=null; }
  }else{
    tileCanvas.width=W; tileCanvas.height=H;
    tileCtx.clearRect(0,0,W,H); bgReady=false; mask=null; segTable=null;
  }
}
// world座標→タイルy（描画と同期した向き）
function worldToTileY(y){
  // 画面下がworld基準y=camY。タイルは上から下へ描画している。
  // 画面y = H - (y - camY)。タイルの上端は (-(camY % tileH)) で始まる。
  // よって、タイル内y = ((H - (y - camY)) - (-(camY % tileH))) mod tileH
  //               = (H - y + camY + (camY % tileH)) mod tileH  （定数Hはmodの中では意味を持たないのでOK）
  const m = ((H - y + (camY % tileH)) % tileH + tileH) % tileH;
  return m|0;
}
function isWallWorld(x,y){
  const xi = Math.max(0, Math.min(W-1, Math.floor(x)));
  if(!mask){ // フォールバック：左右端だけ壁
    const m=10*DPR; return (xi<m || xi>W-m);
  }
  const yi = worldToTileY(Math.floor(y));
  return mask[yi*W + xi] === 1;
}
function circleHitWall(x,y,r){
  const a=0.707;
  const pts = [
    [x+r,y],[x-r,y],[x,y+r],[x,y-r],
    [x+r*a,y+r*a],[x-r*a,y+r*a],[x+r*a,y-r*a],[x-r*a,y-r*a]
  ];
  for(const [px,py] of pts){ if(isWallWorld(px,py)) return true; }
  return false;
}
// 指定world yでの“通行セグメント”取得
function openSegmentsAtY(y){
  if(!segTable){ return [[Math.floor(W*0.18), Math.floor(W*0.82)]]; }
  const yi = worldToTileY(Math.floor(y));
  return segTable[yi] && segTable[yi].length ? segTable[yi] : [[Math.floor(W*0.18), Math.floor(W*0.82)]];
}

/* =================== パラメータ =================== */
const STATE={TITLE:0,COUNT:1,PLAY:2,FAST:3,RESULT:4};
let state=STATE.TITLE;
let R=18, SPEED=160, MAXS=320, FRICTION=0.985, BOUNCE=0.55;
let elapsed=0, camY=0, speedMul=1;
function setSizes(){
  const base=Math.min(W,H);
  R = Math.round(base*0.035);
  SPEED = base*0.18;
  MAXS = base*0.33;
}

/* =================== エンティティ =================== */
const players=[];
const cpuKeys=['blue','green','purple','orange','pink','black','yellow'];
function makeBalloon(id,isYou,key,x,y){
  return {id,you:isYou,key,img:BIMG[key],alive:true,x,y,vx:0,vy:0,r:R,maxY:y,aiT:0,pop:0};
}
// 壁の内側で横一列スタート
function initPlayers(){
  players.length=0;
  let yStart = R*2;
  for(let t=0;t<10 && openSegmentsAtY(yStart).length===0; t++) yStart += R*0.8;
  const segs = openSegmentsAtY(yStart);
  let best = segs.reduce((m,a)=> (a[1]-a[0]>m[1]-m[0]?a:m), segs[0]);
  const margin = Math.max(R*2, 14*DPR);
  const L = Math.max(best[0]+margin, margin);
  const Rg = Math.min(best[1]-margin, W-margin);
  const xs=[];
  for(let i=0;i<8;i++) xs.push(Math.round(L + (i+1)*(Rg-L)/(8+1)));
  for(let i=xs.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [xs[i],xs[j]]=[xs[j],xs[i]]; }
  players.push(makeBalloon(0,true,'red', xs[0], yStart));
  for(let i=1;i<8;i++) players.push(makeBalloon(i,false, cpuKeys[(i-1)%cpuKeys.length], xs[i], yStart));
}

/* =================== カラス：数を大幅抑制＆散布 =================== */
const crows=[];
let crowSpawnTimer=0, lastCrowY=0;
function crowMinDist(){ return 150*DPR; } // さらに広げる
function wantCrowCount(){ return Math.min(3, 1 + Math.floor(elapsed/20)); } // 最大3体
function spawnCrow(){
  const w = Math.round(56*DPR), h=Math.round(38*DPR);
  const dir = Math.random()<0.5? -1 : 1;
  const yMin = camY + H*0.5, yMax = camY + H*1.7; // 画面の上側〜かなり先に
  let placed=false, tries=0;
  while(!placed && tries<40){
    tries++;
    const y = yMin + Math.random()*(yMax-yMin);
    // 壁内側のセグメントからランダム選択（カラス幅＋余白が入るところ）
    const segs = openSegmentsAtY(y).filter(s => (s[1]-s[0]) >= w*2.2);
    if(!segs.length) continue;
    const seg = segs[Math.floor(Math.random()*segs.length)];
    const margin = Math.max(16*DPR, w*0.8);
    const x = Math.round(seg[0]+margin + Math.random()*(seg[1]-margin - (seg[0]+margin)));
    // 既存カラスと距離
    let ok=true;
    for(const k of crows){
      if(!k.alive) continue;
      const dx=k.x - x, dy=(k.y - y); if(dx*dx+dy*dy < crowMinDist()*crowMinDist()){ ok=false; break; }
    }
    if(!ok) continue;
    crows.push({x: dir<0? x+w : x-w, y, w, h, dir, sp: 60 + Math.random()*50, alive:true});
    placed=true; lastCrowY = y;
  }
}

/* =================== 入力（十字キー＋物理キー） =================== */
const dpad={up:false,down:false,left:false,right:false};
function bindKey(id, k){
  const el=document.getElementById(id);
  const on = (e)=>{ e.preventDefault(); dpad[k]=true; };
  const off= (e)=>{ e.preventDefault(); dpad[k]=false; };
  el.addEventListener('pointerdown', on); el.addEventListener('pointerup', off);
  el.addEventListener('pointerleave', off); el.addEventListener('pointercancel', off);
  el.addEventListener('touchstart', on, {passive:false}); el.addEventListener('touchend', off);
}
bindKey('up','up'); bindKey('down','down'); bindKey('left','left'); bindKey('right','right');

const keys={}; window.addEventListener('keydown',e=>{ keys[e.key.toLowerCase()]=true; });
window.addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });
function inputVec(){
  let x=0,y=0;
  if(dpad.left || keys['arrowleft'] || keys['a']) x-=1;
  if(dpad.right|| keys['arrowright']|| keys['d']) x+=1;
  if(dpad.up   || keys['arrowup']   || keys['w']) y+=1; // 上が+Y
  if(dpad.down || keys['arrowdown'] || keys['s']) y-=1;
  if(x||y){ const l=Math.hypot(x,y)||1; x/=l; y/=l; }
  return {x,y};
}

/* =================== UI / 状態 =================== */
const STATE_TXT={FAST:'<span class="fast">FAST FORWARD（プレイヤー脱落）</span>'};
const btnStart=document.getElementById('btnStart');
const btnRetry=document.getElementById('btnRetry');
const countEl=document.getElementById('count');
const leftInfo=document.getElementById('leftInfo');
const distInfo=document.getElementById('distInfo');
const speedInfo=document.getElementById('speedInfo');
const statusNote=document.getElementById('statusNote');
let player=null, startY=0;

function resetGame(){
  state=STATE.TITLE; elapsed=0; speedMul=1; statusNote.textContent='';
  crows.length=0; crowSpawnTimer=0; lastCrowY=0;
  initPlayers(); player=players[0]; startY=player.y; camY=0;
  btnStart.style.display=''; btnRetry.style.display='none';
  countEl.textContent=''; leftInfo.textContent='残り: 8'; distInfo.textContent='距離: 0 m'; speedInfo.textContent='x1';
}
function startCountdown(){
  state=STATE.COUNT; btnStart.style.display='none';
  let n=3; countEl.textContent='3';
  const step=()=>{ if(n===0){ countEl.textContent='GO'; setTimeout(()=>{countEl.textContent=''; startPlay();},500); return;} countEl.textContent=String(n); n--; setTimeout(step,650); };
  setTimeout(step,650);
}
function startPlay(){
  state=STATE.PLAY; elapsed=0; speedMul=1;
  while(crows.filter(k=>k.alive).length<wantCrowCount()) spawnCrow();
}
function setFast(){
  if(state===STATE.PLAY){ state=STATE.FAST; speedMul=3; speedInfo.textContent='x3'; statusNote.innerHTML=STATE_TXT.FAST; }
}
function finishGame(){ state=STATE.RESULT; btnRetry.style.display=''; statusNote.textContent='レース終了'; }
btnStart.addEventListener('click', startCountdown);
btnRetry.addEventListener('click', resetGame);

/* =================== CPU AI（強化） ===================
   1) 基本は上へ
   2) 現在位置より少し先のyで“開いている帯”を見て、そこに含まれる最近傍の中心へステア
   3) 壁クリアランス（近い側から離れる）
   4) カラス予測回避
   5) 仲間と分離（密集回避）
====================================================== */
function clearanceLR(x,y,limit){
  let L=0,Rd=0;
  for(let dx=1; dx<=limit; dx++){
    if(!L && isWallWorld(x-dx,y)) L=dx;
    if(!Rd && isWallWorld(x+dx,y)) Rd=dx;
    if(L && Rd) break;
  }
  return {left:L||limit+1, right:Rd||limit+1};
}

/* =================== Update =================== */
function update(dt){
  if(state===STATE.TITLE || state===STATE.COUNT || state===STATE.RESULT) return;
  const sdt = dt * (state===STATE.FAST? 3:1);
  elapsed += sdt;

  // プレイヤー
  if(player.alive){
    const v=inputVec();
    const acc=SPEED*0.95;
    player.vx += v.x*acc*dt;
    player.vy += v.y*acc*dt;
  }

  // CPU
  for(const p of players){
    if(p.you || !p.alive) continue;
    let ax=0, ay=0;

    // (1) 上へ
    ay += 1.0;

    // (2) 先読みして帯の中心を追う
    const look = p.y + Math.max(120*DPR, Math.min(300*DPR, Math.hypot(p.vx,p.vy)*0.4));
    const segs = openSegmentsAtY(look);
    let targetX = p.x;
    // いま居る帯を優先、なければ最近傍の帯中心
    let inSeg = segs.find(s => p.x>=s[0] && p.x<=s[1]);
    if(inSeg){ targetX = (inSeg[0]+inSeg[1])/2; }
    else{
      let best=Infinity, cx=p.x;
      for(const s of segs){ const c=(s[0]+s[1])/2; const d=Math.abs(c-p.x); if(d<best){best=d; cx=c;} }
      targetX = cx;
    }
    ax += (targetX - p.x) * 0.0048;   // 追従係数

    // (3) 壁クリアランス
    const clr = clearanceLR(p.x,p.y, Math.round(160*DPR));
    ax += (clr.right - clr.left) * 0.006;

    // (4) カラス回避（先読み）
    let rx=0, ry=0, cnt=0;
    for(const k of crows){
      if(!k.alive) continue;
      const px = k.x + k.dir*k.sp*0.7, py=k.y;
      const dx=p.x-px, dy=p.y-py, d2=dx*dx+dy*dy;
      if(d2 < (260*DPR)*(260*DPR)){ const d=Math.sqrt(d2)||1; rx += dx/d; ry += dy/d; cnt++; }
    }
    if(cnt){ ax += (rx/cnt)*0.9; ay += (ry/cnt)*0.9; }

    // (5) 分離
    rx=0; ry=0; cnt=0;
    for(const q of players){
      if(q===p || !q.alive) continue;
      const dx=p.x-q.x, dy=p.y-q.y, d2=dx*dx+dy*dy, minD=(p.r+q.r)*2.7;
      if(d2 < minD*minD){ const d=Math.sqrt(d2)||1; rx += dx/d; ry += dy/d; cnt++; }
    }
    if(cnt){ ax += (rx/cnt)*0.55; ay += (ry/cnt)*0.55; }

    // 少ノイズ
    ax += Math.sin((elapsed*0.7 + p.id))*0.12;

    const acc=SPEED*0.78;
    p.vx += ax*acc*dt; p.vy += ay*acc*dt;
  }

  // 速度・移動・壁バウンド
  for(const p of players){
    if(!p.alive) continue;
    p.vx *= FRICTION; p.vy *= FRICTION;
    const v = Math.hypot(p.vx,p.vy), LIM=MAXS; if(v>LIM){ p.vx=p.vx/v*LIM; p.vy=p.vy/v*LIM; }

    let nx=p.x + p.vx*dt, ny=p.y + p.vy*dt;
    if(circleHitWall(nx, p.y, p.r)){ p.vx*=-BOUNCE; nx=p.x + p.vx*dt; }
    if(circleHitWall(p.x, ny, p.r)){ p.vy*=-BOUNCE; ny=p.y + p.vy*dt; }
    p.x=nx; p.y=ny;
    if(p.y>p.maxY) p.maxY=p.y;
  }

  // 風船反発
  for(let i=0;i<players.length;i++){
    const a=players[i]; if(!a.alive) continue;
    for(let j=i+1;j<players.length;j++){
      const b=players[j]; if(!b.alive) continue;
      const dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy), min=a.r+b.r;
      if(d>0 && d<min){
        const nx=dx/d, ny=dy/d, push=(min-d)*0.6;
        a.x-=nx*push*0.5; a.y-=ny*push*0.5;
        b.x+=nx*push*0.5; b.y+=ny*push*0.5;
        const rvx=b.vx-a.vx, rvy=b.vy-a.vy, rel=rvx*nx+rvy*ny;
        if(rel>0){ const imp=rel*0.5; a.vx+=nx*imp*BOUNCE; a.vy+=ny*imp*BOUNCE; b.vx-=nx*imp*BOUNCE; b.vy-=ny*imp*BOUNCE; }
      }
    }
  }

  // カラス：数制限＋散布（タイマー制御）
  const aliveCrows = crows.filter(k=>k.alive).length;
  crowSpawnTimer += sdt;
  const want = wantCrowCount();
  if(aliveCrows < want && crowSpawnTimer > 1.2){ // 最短1.2秒間隔
    spawnCrow(); crowSpawnTimer = 0;
  }
  for(const k of crows){
    if(!k.alive) continue;
    const spMul = 1 + Math.min(1.1, elapsed/60);
    k.x += k.dir * k.sp * spMul * dt;

    // 壁に近づいたら反転（余裕を持って）
    if(isWallWorld(k.x - 4, k.y) && k.dir<0) k.dir=1;
    if(isWallWorld(k.x + k.w + 4, k.y) && k.dir>0) k.dir=-1;

    // 近すぎるカラス同士を分散
    for(const m of crows){
      if(m===k || !m.alive) continue;
      const dx=k.x-m.x, dy=k.y-m.y, d2=dx*dx+dy*dy;
      const md = crowMinDist()*0.9;
      if(d2 < md*md){ const inv = 18*dt/Math.sqrt(d2+1e-3); k.x += dx*inv; }
    }

    if(k.y < camY - H*0.9) k.alive=false;
  }

  // カラス衝突
  for(const p of players){
    if(!p.alive) continue;
    for(const k of crows){
      if(!k.alive) continue;
      const rx = Math.max(k.x, Math.min(p.x, k.x+k.w));
      const ry = Math.max(k.y, Math.min(p.y, k.y+k.h));
      const d2 = (p.x-rx)*(p.x-rx) + (p.y-ry)*(p.y-ry);
      if(d2 < (p.r*p.r*0.7)){
        p.alive=false; p.pop=0;
        if(p===player) setFast();
        break;
      }
    }
  }

  // 情報表示
  const distM = Math.max(0, (player.maxY - startY)/(40*DPR));
  distInfo.textContent = '距離: ' + distM.toFixed(1) + ' m';
  leftInfo.textContent = '残り: ' + players.filter(p=>p.alive).length;

  // カメラ（自分の少し上）
  const target = Math.max(0, player.y - H*0.45);
  camY += (target - camY) * 0.12;

  // 終了
  if(players.filter(p=>p.alive).length<=1 && (state===STATE.PLAY || state===STATE.FAST)) finishGame();
}

/* =================== 描画 =================== */
function drawBackground(){
  if(tileCanvas && tileH>0){
    const off = - (camY % tileH);
    for(let y=off; y<H; y+=tileH){ ctx.drawImage(tileCanvas, 0, Math.floor(y)); }
  }else{
    const g=ctx.createLinearGradient(0,H,0,0);
    g.addColorStop(0,'#0b1020'); g.addColorStop(1,'#1a2338');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#163a7a'; ctx.fillRect(0,0,10*DPR,H); ctx.fillRect(W-10*DPR,0,10*DPR,H);
  }
}
function worldToScreenY(y){ return Math.floor(H - (y - camY)); }

function draw(){
  drawBackground();

  // カラス
  for(const k of crows){
    if(!k.alive) continue;
    const sy = worldToScreenY(k.y);
    const img = k.dir<0 ? K1 : K2;
    if(img && img.complete && img.naturalWidth){
      ctx.drawImage(img, Math.floor(k.x), Math.floor(sy - k.h), Math.floor(k.w), Math.floor(k.h));
    }else{
      ctx.fillStyle='#222'; ctx.fillRect(k.x, sy-k.h, k.w, k.h);
      ctx.fillStyle='#f90'; ctx.fillRect(k.x + (k.dir<0? k.w*0.7: k.w*0.1), sy-k.h*0.65, k.w*0.2, k.h*0.2);
    }
  }

  // 風船（破裂アニメ含む）
  for(const p of players){
    const sy = worldToScreenY(p.y);
    if(!p.alive){
      if(p.pop<1){
        p.pop += 0.03 * (state===STATE.FAST?3:1);
        const a = Math.max(0, 1-p.pop), s=1+p.pop*1.2;
        ctx.save(); ctx.globalAlpha=a; ctx.translate(p.x, sy); ctx.scale(s,s);
        drawBalloon(p,0,0,true); ctx.restore();
      }
      continue;
    }
    drawBalloon(p, p.x, sy, false);
  }
}
function drawBalloon(p, sx, sy){
  ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.lineWidth=Math.max(1, 2*DPR);
  ctx.beginPath(); ctx.moveTo(sx, sy+p.r*0.6); ctx.lineTo(sx, sy+p.r*1.4); ctx.stroke();
  const img=p.img, size=Math.round(p.r*2.2);
  if(img && img.complete && img.naturalWidth){
    ctx.drawImage(img, Math.floor(sx-size/2), Math.floor(sy-size/2), size, size);
  }else{
    ctx.fillStyle = p.you ? '#ff4d6d' : '#7fd0ff';
    ctx.beginPath(); ctx.arc(sx, sy, p.r, 0, Math.PI*2); ctx.fill();
  }
  if(p.you){
    ctx.fillStyle='#111'; ctx.font=`${Math.round(p.r*0.9)}px sans-serif`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('M', sx, sy);
  }
}

/* =================== ループ =================== */
let last=0;
function loop(t){
  if(!last) last=t;
  const dt = Math.min(0.033, (t-last)/1000); last=t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* =================== 起動 =================== */
resize();
buildTileAndMask();
initPlayers();
requestAnimationFrame(loop);
})();
</script>
</body>
</html>
