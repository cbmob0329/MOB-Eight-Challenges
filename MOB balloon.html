<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
<title>MOB balloon</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{
    --bg:#0b0c10; --panel:#121621; --panel2:#171c2a; --fg:#e9eef7; --dim:#9aa3b2; --accent:#13c4ff; --accent2:#ff3e7f; --ok:#25d366; --warn:#ffb020;
  }
  /* ====== 固定スマホビュー（PCでも同じ見た目） ====== */
  html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif;}
  #app-wrap{
    position:fixed; inset:0; display:grid; place-items:center;
  }
  /* iPhone系に近い縦長プレビュー領域（PCでも同一UIサイズ） */
  /* 必要なら下の width/height を調整（幅基準で拡大縮小されます） */
  #phone{
    width: 390px; /* iPhone 12/13/14 付近 */
    height: 780px;
    background:linear-gradient(160deg,#0b0c10,#0e1220 60%,#0b0c10);
    border-radius: 24px;
    box-shadow: 0 10px 40px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06);
    overflow:hidden;
    display:flex; flex-direction:column;
  }
  /* 実ゲーム領域 */
  #topbar{
    flex:0 0 48px; display:flex; align-items:center; justify-content:space-between;
    padding:0 12px; background:var(--panel); border-bottom:1px solid rgba(255,255,255,.06);
    font-weight:600; letter-spacing:.3px;
  }
  #hud{
    display:flex; gap:10px; align-items:center; font-size:12px; color:var(--dim);
  }
  #hud b{ color:var(--fg); font-weight:700; }
  #stage-wrap{
    position:relative; flex:1; display:grid; place-items:center; background:var(--panel2);
  }
  /* ステージは常に正方形。内部キャンバスをCSS拡大して鮮明に表示 */
  #stage{
    width: min(92vw, calc(100vh - 160px)); /* 念のための保険（phone枠外で使った時も四角を維持） */
    aspect-ratio: 1 / 1;
    max-width: calc(100% - 16px);
    max-height: calc(100% - 16px);
    background:#000;
    border-radius: 12px;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.08);
    position:relative;
  }
  canvas{ width:100%; height:100%; display:block; border-radius:12px; image-rendering: pixelated; }
  /* オーバーレイUI */
  .overlay{
    position:absolute; inset:0; display:grid; place-items:center; pointer-events:none;
  }
  .center-panel{
    background:rgba(10,12,20,.85);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px; padding:18px; width:85%; max-width:320px; text-align:center;
    box-shadow:0 12px 40px rgba(0,0,0,.5);
    pointer-events:auto;
  }
  .title{ font-size:22px; font-weight:800; letter-spacing:.5px; margin-bottom:6px; }
  .sub{ font-size:12px; color:var(--dim); margin-bottom:14px; }
  .btn{
    appearance:none; border:none; background:linear-gradient(180deg,var(--accent),#0eaee6);
    color:#001018; font-weight:800; padding:12px 16px; border-radius:12px; cursor:pointer; width:100%;
    box-shadow: 0 8px 18px rgba(19,196,255,.35);
  }
  .btn:active{ transform: translateY(1px); }
  .ghost{ background:transparent; color:var(--fg); border:1px solid rgba(255,255,255,.2); box-shadow:none; }
  .counter{
    font-size:56px; font-weight:900; letter-spacing:1px; text-shadow:0 4px 18px rgba(0,0,0,.6);
  }
  /* 十字キー（スマホ前提。PCでは矢印キーも可） */
  #controls{
    flex:0 0 120px; display:flex; align-items:center; justify-content:center; gap:18px;
    background:var(--panel); border-top:1px solid rgba(255,255,255,.06);
  }
  .dpad{
    width:156px; height:156px; position:relative;
  }
  .dpad button{
    position:absolute; width:48px; height:48px; border-radius:12px; background:#1c2334; border:1px solid rgba(255,255,255,.1);
    color:#cfe7ff; font-weight:900;
    touch-action:none;
  }
  .dpad button:active{ background:#24304a; }
  .up{left:54px; top:0}
  .down{left:54px; bottom:0}
  .left{left:0; top:54px}
  .right{right:0; top:54px}
  .legend{ font-size:11px; color:var(--dim); }
  /* スコアボード */
  table{ width:100%; border-collapse:collapse; color:#eaf2ff; }
  th,td{ padding:6px 8px; border-bottom:1px dashed rgba(255,255,255,.12); font-size:13px; text-align:left; }
  th{ color:#9fb6d5; font-weight:700; }
  .rank1{ color:#ffd54a; font-weight:800; }
  .rank2{ color:#c6d7ff; font-weight:800; }
  .rank3{ color:#ffb48a; font-weight:800; }
  .pill{ padding:2px 8px; border-radius:999px; background:#1f2a44; border:1px solid rgba(255,255,255,.12); font-size:11px; }
  .muted{ color:var(--dim); }
</style>
</head>
<body>
<div id="app-wrap">
  <div id="phone" aria-label="MOB balloon - mobile fixed view">
    <div id="topbar">
      <div>MOB balloon</div>
      <div id="hud">
        <span>R:<b id="roundNum">1</b>/3</span>
        <span>生存:<b id="alive">8</b></span>
        <span>時間:<b id="time">0.0</b>s</span>
        <span class="pill" id="speedTag">通常</span>
      </div>
    </div>

    <div id="stage-wrap">
      <div id="stage">
        <canvas id="cv" width="1000" height="1000"></canvas>

        <!-- タイトル/スタート -->
        <div class="overlay" id="startOverlay">
          <div class="center-panel">
            <div class="title">MOB balloon</div>
            <div class="sub">風船でフワフワ移動し、<b>カラス</b>から逃げ続けよう！<br/>十字キーで操作。8人で生存競争。</div>
            <button class="btn" id="btnStart">ゲームスタート</button>
          </div>
        </div>

        <!-- カウントダウン -->
        <div class="overlay" id="countOverlay" style="display:none;">
          <div class="counter" id="countLabel">3</div>
        </div>

        <!-- ラウンド結果 -->
        <div class="overlay" id="roundOverlay" style="display:none;">
          <div class="center-panel" id="roundPanel">
            <div class="title">ラウンド結果</div>
            <div class="sub" id="roundSummary">…</div>
            <table id="roundTable"></table>
            <div style="display:flex; gap:8px; margin-top:12px;">
              <button class="btn" id="btnNext">次のラウンド</button>
              <button class="btn ghost" id="btnRetry">やり直す</button>
            </div>
          </div>
        </div>

        <!-- 総合結果 -->
        <div class="overlay" id="finalOverlay" style="display:none;">
          <div class="center-panel">
            <div class="title">総合結果</div>
            <div class="sub">全3ラウンドの合計ポイント</div>
            <table id="finalTable"></table>
            <div style="display:flex; gap:8px; margin-top:12px;">
              <button class="btn" id="btnAgain">もう一度</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 十字キー -->
    <div id="controls">
      <div class="dpad" aria-label="directional pad">
        <button class="up" data-dir="up">▲</button>
        <button class="down" data-dir="down">▼</button>
        <button class="left" data-dir="left">◀</button>
        <button class="right" data-dir="right">▶</button>
      </div>
      <div class="legend">十字キーで移動（PCは矢印キーも可）</div>
    </div>
  </div>
</div>

<script>
/* ========== 画像読み込み（同階層・ファイル名厳守） ========== */
const ASSETS = {
  bg: "MOBhai.png",
  crowR: "karasu1.png",
  crowL: "karasu2.png",
  balloons: {
    Black: "Blackb.png",
    BlueTypo: "Buleb.png", // 指定どおり（綴り注意）
    Green: "Greenb.png",
    Purple: "murab.png",
    Orange: "Orangeb.png",
    Pink: "Pinkb.png",
    Red: "Redb.png",
    Yellow: "yellowb.png"
  }
};
const balloonOrder = ["Red","BlueTypo","Green","Purple","Orange","Pink","Yellow","Black"];

/* ========== 基本DOM ========== */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');

const startOverlay = document.getElementById('startOverlay');
const countOverlay = document.getElementById('countOverlay');
const countLabel = document.getElementById('countLabel');
const roundOverlay = document.getElementById('roundOverlay');
const roundTable = document.getElementById('roundTable');
const roundSummary = document.getElementById('roundSummary');
const finalOverlay = document.getElementById('finalOverlay');
const finalTable = document.getElementById('finalTable');

const roundNumEl = document.getElementById('roundNum');
const aliveEl = document.getElementById('alive');
const timeEl = document.getElementById('time');
const speedTag = document.getElementById('speedTag');

const btnStart = document.getElementById('btnStart');
const btnNext = document.getElementById('btnNext');
const btnRetry = document.getElementById('btnRetry');
const btnAgain = document.getElementById('btnAgain');

/* ========== ステージ設定 ========== */
const STAGE_SIZE = 1000; // 物理ロジック座標は常に正方形1000x1000
const HALF = STAGE_SIZE / 2;
let images = {};
let ready = false;

/* ========== ゲーム進行 ========== */
const MAX_PLAYERS = 8;
const ROUNDS_MAX = 3;
const POINTS_MAP = [15,10,7,5,3,1,0,0]; // 1位～8位
let roundIndex = 0;
let leaderboard = []; // {id,name,total}
let colorsForRound = []; // 各ラウンド色割り当て（Redはプレイヤー）

/* ========== エンティティ ========== */
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,min,max){ return v<min?min:(v>max?max:v); }

class Balloon{
  constructor(id, name, colorKey, isPlayer){
    this.id=id; this.name=name; this.colorKey=colorKey; this.isPlayer=isPlayer;
    this.r = 26; // 風船半径（描画時に画像サイズへ変換）
    this.x=0; this.y=0;
    this.vx=0; this.vy=0;
    this.ax=0; this.ay=0;
    this.alive=true;
    this.popping=false; this.popTimer=0;
    this.timeAlive=0;
    this.rank=null; // 1=優勝（最後まで残った）
    this.control = {up:false,down:false,left:false,right:false};
    this.aiTargetAngle = rand(0,Math.PI*2);
    this.aiChangeT = rand(0.6,1.2);
  }
  reset(x,y){
    this.x=x; this.y=y; this.vx=this.vy=0; this.ax=this.ay=0;
    this.alive=true; this.popping=false; this.popTimer=0; this.timeAlive=0; this.rank=null;
  }
}

class Crow{
  constructor(){
    this.x=rand(200,800); this.y=rand(200,800);
    this.vx=0; this.vy=0;
    this.speed=75; // 初速（後半加速）
    this.size = 52; // 風船2個分くらいの見た目（描画側で少し拡大）
    this.dirR = true; // 右向きか
  }
}

/* ========== ゲーム状態 ========== */
let balloons = [];
let crows = [];
let gameTime = 0; // 現ラウンドの経過（秒）
let simSpeed = 1.0; // プレイヤー撃沈後 3.0 に
let playing = false;
let counting = false;
let nextCrowTime = 0;
let ended = false;
let placements = []; // 敗退順の逆（残った順）を記録 → ラウンド終了時にrank付与

/* ========== 入力（十字キー + キーボード） ========== */
const input = {up:false,down:false,left:false,right:false};
function bindDPad(){
  const controls = document.querySelectorAll('.dpad button');
  controls.forEach(btn=>{
    const dir = btn.dataset.dir;
    const set = v=>{ input[dir]=v; if(playerBalloon) playerBalloon.control[dir]=v; };
    const on = e=>{ e.preventDefault(); set(true); };
    const off = e=>{ e.preventDefault(); set(false); };
    btn.addEventListener('touchstart', on, {passive:false});
    btn.addEventListener('touchend', off);
    btn.addEventListener('touchcancel', off);
    btn.addEventListener('mousedown', on);
    btn.addEventListener('mouseup', off);
    btn.addEventListener('mouseleave', off);
  });
}
window.addEventListener('keydown', e=>{
  if(e.key==="ArrowUp") input.up=true;
  if(e.key==="ArrowDown") input.down=true;
  if(e.key==="ArrowLeft") input.left=true;
  if(e.key==="ArrowRight") input.right=true;
});
window.addEventListener('keyup', e=>{
  if(e.key==="ArrowUp") input.up=false;
  if(e.key==="ArrowDown") input.down=false;
  if(e.key==="ArrowLeft") input.left=false;
  if(e.key==="ArrowRight") input.right=false;
});

/* ========== 画像ロード ========== */
function loadImage(src){
  return new Promise((res,rej)=>{
    const img = new Image();
    img.onload=()=>res(img);
    img.onerror=()=>rej(new Error("fail:"+src));
    img.src = src;
  });
}
async function loadAssets(){
  const list = [
    ['bg', ASSETS.bg],
    ['crowR', ASSETS.crowR],
    ['crowL', ASSETS.crowL],
    ['bBlack', ASSETS.balloons.Black],
    ['bBlue', ASSETS.balloons.BlueTypo],
    ['bGreen', ASSETS.balloons.Green],
    ['bPurple', ASSETS.balloons.Purple],
    ['bOrange', ASSETS.balloons.Orange],
    ['bPink', ASSETS.balloons.Pink],
    ['bRed', ASSETS.balloons.Red],
    ['bYellow', ASSETS.balloons.Yellow],
  ];
  const imgs = await Promise.all(list.map(([k,src])=>loadImage(src).then(img=>[k,img])));
  imgs.forEach(([k,img])=>images[k]=img);
  ready = true;
}

/* ========== 設定とユーティリティ ========== */
let playerBalloon = null;
function colorToImageKey(colorKey){
  switch(colorKey){
    case 'Black': return 'bBlack';
    case 'BlueTypo': return 'bBlue';
    case 'Green': return 'bGreen';
    case 'Purple': return 'bPurple';
    case 'Orange': return 'bOrange';
    case 'Pink': return 'bPink';
    case 'Red': return 'bRed';
    case 'Yellow': return 'bYellow';
  }
  return 'bRed';
}
function nameFromColor(colorKey){
  return {
    Black:'Black', BlueTypo:'Blue', Green:'Green', Purple:'Purple',
    Orange:'Orange', Pink:'Pink', Red:'Red', Yellow:'Yellow'
  }[colorKey] || colorKey;
}

/* ========== ラウンド構築 ========== */
function setupPlayers(){
  balloons = [];
  // 色割り当て：常にプレイヤーはRed。他は残りから
  const others = balloonOrder.filter(k=>k!=="Red");
  // シャッフル
  for (let i=others.length-1;i>0;i--){
    const j = (Math.random()* (i+1))|0;
    [others[i],others[j]]=[others[j],others[i]];
  }
  const allColors = ["Red", ...others.slice(0,7)];
  colorsForRound = allColors;

  for(let i=0;i<MAX_PLAYERS;i++){
    const ck = allColors[i];
    const isPlayer = (ck==="Red");
    const b = new Balloon(i, isPlayer? "YOU (Red)":"CPU ("+nameFromColor(ck)+")", ck, isPlayer);
    balloons.push(b);
    if(isPlayer) playerBalloon = b;
  }

  // 横一列：Y固定、Xは幅全体に等間隔＋並び順をランダム
  const order = [...Array(MAX_PLAYERS).keys()];
  for (let i=order.length-1;i>0;i--){
    const j = (Math.random()* (i+1))|0;
    [order[i],order[j]]=[order[j],order[i]];
  }
  const y = 150;
  const margin = 80;
  const span = STAGE_SIZE - margin*2;
  order.forEach((idx,k)=>{
    const b = balloons[idx];
    const x = margin + span * (k/(MAX_PLAYERS-1));
    b.reset(x,y);
  });
}

function setupCrows(){
  crows = [];
  const c = new Crow();
  c.x = STAGE_SIZE/2 + rand(-120,120);
  c.y = STAGE_SIZE*0.75 + rand(-50,50);
  crows.push(c);
  nextCrowTime = 10; // 10秒ごとに1匹ずつ増える
}

function resetRound(){
  gameTime = 0;
  simSpeed = 1.0;
  playing = false;
  counting = false;
  ended = false;
  placements = []; // 最後に残った順で push していく（勝者が最後に入る）

  setupPlayers();
  setupCrows();

  aliveEl.textContent = MAX_PLAYERS;
  timeEl.textContent = "0.0";
  speedTag.textContent = "通常";
}

function startCountdown(){
  counting = true;
  startOverlay.style.display="none";
  countOverlay.style.display="grid";
  let seq = [3,2,1,"GO"];
  let i=0;
  const tick=()=>{
    countLabel.textContent = seq[i];
    i++;
    if(i<seq.length){
      setTimeout(tick, 700);
    }else{
      setTimeout(()=>{
        countOverlay.style.display="none";
        playing = true;
        counting = false;
      }, 400);
    }
  };
  tick();
}

/* ========== 物理とAI ========== */
function step(dt){
  if(!playing) return;

  // プレイヤー死亡 → 高速モード突入（3倍）
  if(playerBalloon && (!playerBalloon.alive || playerBalloon.popping)){
    simSpeed = 3.0;
    speedTag.textContent = "高速×3";
  }

  dt *= simSpeed;
  gameTime += dt;

  // 10秒ごとにカラス追加
  if(gameTime >= nextCrowTime){
    const c = new Crow();
    // 端付近から登場
    const edge = Math.random()<0.5 ? 'x' : 'y';
    if(edge==='x'){
      c.x = Math.random()<0.5 ? 40 : STAGE_SIZE-40;
      c.y = rand(120, STAGE_SIZE-120);
    }else{
      c.x = rand(120, STAGE_SIZE-120);
      c.y = Math.random()<0.5 ? 40 : STAGE_SIZE-40;
    }
    // 後半ほど最初から速い
    c.speed = 75 + Math.min(90, gameTime*1.2);
    crows.push(c);
    nextCrowTime += 10;
  }

  // 後半は全カラスの速度をじわ上げ
  const speedBoost = 1 + Math.min(0.8, Math.max(0, (gameTime-30)/60)); // 30秒後から徐々に最大+80%
  crows.forEach(cr=> cr.speed *= (0.999 + 0.001*speedBoost)); // なだらかに

  // 入力→プレイヤー加速度
  if(playerBalloon && playerBalloon.alive && !playerBalloon.popping){
    const acc= 170; // フワフワ感を維持する加速
    playerBalloon.ax = (playerBalloon.control.right?1:0) - (playerBalloon.control.left?1:0);
    playerBalloon.ay = (playerBalloon.control.down?1:0) - (playerBalloon.control.up?1:0);
    // 斜め補正
    const len = Math.hypot(playerBalloon.ax, playerBalloon.ay) || 1;
    playerBalloon.ax = (playerBalloon.ax/len)*acc;
    playerBalloon.ay = (playerBalloon.ay/len)*acc;
  }

  // CPUのゆらぎAI（カラスと他風船を避けつつフワフワ）
  balloons.forEach(b=>{
    if(!b.isPlayer && b.alive && !b.popping){
      b.aiChangeT -= dt;
      if(b.aiChangeT<=0){
        b.aiChangeT = rand(0.5,1.2);
        // たまに目標角度を変える（ランダム＋カラス回避）
        let avoidX=0, avoidY=0;
        crows.forEach(c=>{
          const dx = b.x - c.x, dy = b.y - c.y;
          const d2 = dx*dx+dy*dy;
          if(d2< 220*220){ avoidX += dx; avoidY += dy; } // 近い時は離れる
        });
        const bias = Math.atan2(avoidY,avoidX);
        b.aiTargetAngle = isFinite(bias)? bias + rand(-0.7,0.7) : rand(0,Math.PI*2);
      }
      const acc= 150;
      b.ax = Math.cos(b.aiTargetAngle)*acc;
      b.ay = Math.sin(b.aiTargetAngle)*acc;
      // 壁に近いと中心へバイアス
      const margin=90, centerPull=120;
      if(b.x<margin) b.ax += centerPull;
      if(b.x>STAGE_SIZE-margin) b.ax -= centerPull;
      if(b.y<margin) b.ay += centerPull;
      if(b.y>STAGE_SIZE-margin) b.ay -= centerPull;
    }
  });

  // 速度更新（空気抵抗）
  const drag = 0.88;
  const vmax = 240;
  balloons.forEach(b=>{
    if(!b.alive) return;
    // ポップ中は動かさない
    if(b.popping){
      b.popTimer += dt;
      if(b.popTimer>=0.6){
        b.alive=false;
        registerElimination(b);
      }
      return;
    }
    // 加速度→速度
    b.vx = (b.vx + b.ax*dt)*drag;
    b.vy = (b.vy + b.ay*dt)*drag;
    // 上限
    const sp = Math.hypot(b.vx,b.vy);
    if(sp>vmax){ b.vx = b.vx/sp*vmax; b.vy = b.vy/sp*vmax; }
    // 位置
    b.x += b.vx*dt;
    b.y += b.vy*dt;
    // 壁反射（見えない壁）
    const r = b.r;
    if(b.x<r){ b.x=r; b.vx = Math.abs(b.vx)*0.6; } // 弾かれる少し
    if(b.x>STAGE_SIZE-r){ b.x=STAGE_SIZE-r; b.vx = -Math.abs(b.vx)*0.6; }
    if(b.y<r){ b.y=r; b.vy = Math.abs(b.vy)*0.6; }
    if(b.y>STAGE_SIZE-r){ b.y=STAGE_SIZE-r; b.vy = -Math.abs(b.vy)*0.6; }

    b.timeAlive += dt;
  });

  // 風船同士の弾き
  for(let i=0;i<balloons.length;i++){
    const a = balloons[i]; if(!a.alive || a.popping) continue;
    for(let j=i+1;j<balloons.length;j++){
      const b = balloons[j]; if(!b.alive || b.popping) continue;
      const dx=b.x-a.x, dy=b.y-a.y;
      const dist = Math.hypot(dx,dy);
      const min = a.r + b.r;
      if(dist>0 && dist<min){
        const nx = dx/dist, ny=dy/dist;
        const overlap = (min - dist)*0.6;
        a.x -= nx*overlap*0.5; a.y -= ny*overlap*0.5;
        b.x += nx*overlap*0.5; b.y += ny*overlap*0.5;
        // 反射（少しだけ）
        const bounce = 140;
        a.vx -= nx*bounce; a.vy -= ny*bounce;
        b.vx += nx*bounce; b.vy += ny*bounce;
      }
    }
  }

  // カラスAI（最も近い生存風船を狙う）
  crows.forEach(cr=>{
    // 目標：一番近い生存風船
    let target=null, best=1e9;
    balloons.forEach(b=>{
      if(!b.alive || b.popping) return;
      const dx=b.x-cr.x, dy=b.y-cr.y;
      const d2 = dx*dx+dy*dy;
      if(d2<best){ best=d2; target=b; }
    });
    if(target){
      const dx=target.x-cr.x, dy=target.y-cr.y;
      const dist = Math.hypot(dx,dy)||1;
      const ux=dx/dist, uy=dy/dist;
      const sp = cr.speed;
      cr.vx = ux*sp; cr.vy=uy*sp;
      cr.x += cr.vx*dt; cr.y += cr.vy*dt;
      cr.dirR = cr.vx>=0;
      // 壁には出られない（反射）
      if(cr.x<30){ cr.x=30; cr.vx = Math.abs(cr.vx); }
      if(cr.x>STAGE_SIZE-30){ cr.x=STAGE_SIZE-30; cr.vx = -Math.abs(cr.vx); }
      if(cr.y<30){ cr.y=30; cr.vy = Math.abs(cr.vy); }
      if(cr.y>STAGE_SIZE-30){ cr.y=STAGE_SIZE-30; cr.vy = -Math.abs(cr.vy); }
      // 風船ヒット判定
      balloons.forEach(b=>{
        if(!b.alive || b.popping) return;
        const d = Math.hypot(b.x-cr.x, b.y-cr.y);
        if(d < (b.r + cr.size*0.6)){ // 少し広め
          // バーン！ -> 破裂フェードアウト
          b.popping = true; b.popTimer=0;
          // 当たった瞬間に少し押す
          const nx = (b.x-cr.x)/(d||1), ny=(b.y-cr.y)/(d||1);
          b.vx += nx*260; b.vy += ny*260;
        }
      });
    }
  });

  // 生存数カウント
  const aliveCount = balloons.filter(b=>b.alive || b.popping).length;
  aliveEl.textContent = aliveCount;

  // ラウンド終了判定（最後の1人が決まったら）
  if(!ended){
    const live = balloons.filter(b=>b.alive || b.popping);
    if(live.length<=1){
      // 最後の1人（aliveのまま or popping中でも最後なら勝者）
      const winner = live[0] || null;
      if(winner && winner.rank==null){
        winner.rank = 1;
        placements.push(winner);
      }
      endRound();
    }
  }

  // HUD時間（プレイヤー生存時間）
  timeEl.textContent = (playerBalloon? playerBalloon.timeAlive : 0).toFixed(1);
}

function registerElimination(b){
  if(b.rank!=null) return; // 二重防止
  // 残存人数に応じて rank を後で付与したいので、順番記録のみ
  placements.push(b);
  // rank はラウンド終了時に確定させる
}

/* ========== 描画 ========== */
function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);
  // 背景（正方形にトリムされた MOBhai.png を全面に）
  if(images.bg){
    ctx.drawImage(images.bg, 0,0, STAGE_SIZE, STAGE_SIZE);
  }else{
    ctx.fillStyle="#0a0e18";
    ctx.fillRect(0,0,STAGE_SIZE,STAGE_SIZE);
  }

  // 枠（見えない壁だが視覚的な薄枠）
  ctx.strokeStyle = "rgba(255,255,255,.15)";
  ctx.lineWidth = 4;
  ctx.strokeRect(2,2,STAGE_SIZE-4,STAGE_SIZE-4);

  // カラス
  crows.forEach(cr=>{
    const img = cr.dirR ? images.crowR : images.crowL;
    if(img){
      const s = cr.size*2.0; // “風船2個分くらい”が分かるよう少し大きめ表示
      ctx.drawImage(img, cr.x - s*0.5, cr.y - s*0.5, s, s);
    }else{
      ctx.fillStyle="#000";
      ctx.beginPath(); ctx.arc(cr.x,cr.y, cr.size, 0, Math.PI*2); ctx.fill();
    }
  });

  // 風船
  balloons.forEach(b=>{
    if(!b.alive && !b.popping) return;
    const key = colorToImageKey(b.colorKey);
    const img = images[key];
    let scale = 2.0; // 画像基準拡大（スマホ見やすさ）
    if(b.popping){
      // 破裂フェードアウト（拡大＋透明）
      const t = clamp(b.popTimer/0.6, 0, 1);
      const alpha = 1 - t;
      const blow = 1 + t*0.6;
      ctx.save();
      ctx.globalAlpha = alpha;
      const s = b.r*2*scale*blow;
      if(img) ctx.drawImage(img, b.x - s*0.5, b.y - s*0.5, s, s);
      else{ ctx.fillStyle="rgba(255,255,255,"+alpha+")"; ctx.beginPath(); ctx.arc(b.x,b.y,b.r*blow,0,Math.PI*2); ctx.fill(); }
      ctx.restore();
    }else{
      const s = b.r*2*scale;
      if(img) ctx.drawImage(img, b.x - s*0.5, b.y - s*0.5, s, s);
      else{ ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
    }
  });

  // カウントダウン中は半透明ベール
  if(counting){
    ctx.fillStyle="rgba(0,0,0,.2)";
    ctx.fillRect(0,0,STAGE_SIZE,STAGE_SIZE);
  }
}

/* ========== ラウンド終了処理＆スコア ========== */
function endRound(){
  ended = true;
  playing = false;

  // placements は “脱落していった順”なので、最後の勝者が end 判定時に追加済み
  // rank 付与（最後のpushが1位、最初のpushが最下位）
  // 末尾から 1位, 2位, ... とする
  const order = placements.slice().reverse(); // 残った順
  order.forEach((b,i)=> b.rank = i+1);

  // ポイント計算
  const roundRanks = order.map(b=>({ id:b.id, name:b.name, rank:b.rank, color:b.colorKey }));
  const points = new Map();
  roundRanks.forEach(rr=>{
    const p = POINTS_MAP[(rr.rank-1)] || 0;
    points.set(rr.id, p);
  });

  // リーダーボード加算
  roundRanks.forEach(rr=>{
    let row = leaderboard.find(x=>x.id===rr.id);
    if(!row){
      row = {id:rr.id, name:rr.name, total:0, color:rr.color};
      leaderboard.push(row);
    }
    row.total += (points.get(rr.id)||0);
  });

  // 表示
  renderRoundTable(roundRanks, points);
  roundOverlay.style.display="grid";

  // ラウンド数更新
  roundIndex++;
  roundNumEl.textContent = Math.min(roundIndex+1, ROUNDS_MAX);
}

function renderRoundTable(roundRanks, points){
  // あなたの順位＆生存時間
  const you = roundRanks.find(r=>r.id===playerBalloon.id);
  roundSummary.innerHTML = `あなたの順位：<b>${you.rank}</b> 位　／　生存時間：<b>${playerBalloon.timeAlive.toFixed(1)}</b> 秒`;

  // テーブル
  roundTable.innerHTML = `
    <tr><th>順位</th><th>名前</th><th>ポイント</th></tr>
    ${
      roundRanks.map(r=>{
        const pt = points.get(r.id)||0;
        const cls = r.rank===1?'rank1':(r.rank===2?'rank2':(r.rank===3?'rank3':''));
        return `<tr>
          <td class="${cls}">${r.rank}</td>
          <td>${r.name}</td>
          <td>${pt}</td>
        </tr>`;
      }).join('')
    }
  `;
}

/* ========== 総合結果表示 ========== */
function showFinal(){
  // 合計ソート
  const sorted = leaderboard.slice().sort((a,b)=>b.total-a.total);
  finalTable.innerHTML = `
    <tr><th>総合</th><th>名前</th><th>合計</th></tr>
    ${
      sorted.map((r,i)=>{
        const cls = i===0?'rank1':(i===1?'rank2':(i===2?'rank3':''));
        return `<tr>
          <td class="${cls}">${i+1}</td>
          <td>${r.name}</td>
          <td>${r.total}</td>
        </tr>`;
      }).join('')
    }
  `;
  finalOverlay.style.display="grid";
}

/* ========== ループ ========== */
let last=0;
function loop(t){
  if(!ready){ requestAnimationFrame(loop); return; }
  const now = t/1000;
  const dt = Math.min(0.033, now-last || 0.016);
  last = now;

  step(dt);
  draw();

  requestAnimationFrame(loop);
}

/* ========== ボタン動作 ========== */
btnStart.addEventListener('click', ()=>{
  resetRound();
  startCountdown();
});

btnNext.addEventListener('click', ()=>{
  roundOverlay.style.display="none";
  if(roundIndex>=ROUNDS_MAX){
    showFinal();
  }else{
    // 次ラウンドへ
    resetRound();
    startCountdown();
    roundNumEl.textContent = (roundIndex+1);
  }
});

btnRetry.addEventListener('click', ()=>{
  // やり直し：スコアもリセット
  leaderboard = [];
  roundIndex = 0;
  roundNumEl.textContent = 1;
  roundOverlay.style.display="none";
  resetRound();
  startCountdown();
});

btnAgain.addEventListener('click', ()=>{
  // もう一度：全リセット
  finalOverlay.style.display="none";
  leaderboard = [];
  roundIndex = 0;
  roundNumEl.textContent = 1;
  startOverlay.style.display="grid";
});

/* ========== 初期化 ========== */
bindDPad();
loadAssets().then(()=>{
  // タイトル待ち
  requestAnimationFrame(loop);
}).catch(err=>{
  console.error(err);
  alert("画像の読み込みに失敗しました。ファイル名の大文字/小文字と配置を確認してください。");
});

/* ========== スクロール防止（iOS） ========== */
document.addEventListener('gesturestart', e=>e.preventDefault());
document.addEventListener('touchmove', e=>{
  // ステージ・D-Pad操作中はスクロール禁止
  if(e.target.closest('#stage') || e.target.closest('.dpad')) e.preventDefault();
},{passive:false});
</script>
</body>
</html>
