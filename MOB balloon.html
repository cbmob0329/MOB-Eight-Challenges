<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
<title>MOB balloon</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{
    --bg:#0b0c10; --panel:#121621; --panel2:#171c2a; --fg:#e9eef7; --dim:#9aa3b2; --accent:#13c4ff;
  }
  html,body{
    height:100%; margin:0; background:var(--bg); color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif;
    -webkit-touch-callout:none; -webkit-user-select:none; user-select:none;
    touch-action:manipulation;
  }

  /* 端末でもPCでも同じ見た目のスマホ枠 */
  #app-wrap{ position:fixed; inset:0; display:grid; place-items:center; padding:8px; }
  #phone{
    width:390px; height:780px;
    background:linear-gradient(160deg,#0b0c10,#0e1220 60%,#0b0c10);
    border-radius:24px;
    box-shadow:0 10px 40px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06);
    overflow:hidden; display:flex; flex-direction:column;
  }

  /* 上部は薄く、ステージをさらに上に */
  #topbar{
    flex:0 0 40px; display:flex; align-items:center; justify-content:space-between;
    padding:0 10px; background:var(--panel); border-bottom:1px solid rgba(255,255,255,.06);
    font-weight:600;
  }
  #hud{ display:flex; gap:8px; font-size:11px; color:var(--dim); }
  #hud b{ color:var(--fg); }

  /* ===== 真ん中：ステージ + その直下に十字キー（重ならない） ===== */
  #center{
    flex:1; display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
    background:var(--panel2);
    padding:4px 8px 0 8px;
    gap:8px; /* ステージとD-Padの間隔 */
  }

  #stage{
    width:96%; aspect-ratio:1/1; max-height:100%;
    background:#000; border-radius:12px; position:relative;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.08);
    margin-top:2px; /* さらに上へ詰める */
  }
  canvas{ width:100%; height:100%; display:block; border-radius:12px; image-rendering:pixelated; }

  /* オーバーレイ（スタート/カウント/結果） */
  .overlay{ position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; }
  .center-panel{
    background:rgba(10,12,20,.85); border:1px solid rgba(255,255,255,.12);
    border-radius:14px; padding:18px; width:85%; max-width:320px; text-align:center; pointer-events:auto;
  }
  .title{ font-size:20px; font-weight:800; margin-bottom:6px; }
  .sub{ font-size:12px; color:var(--dim); margin-bottom:14px; }
  .btn{ padding:12px; border:none; border-radius:12px; background:var(--accent); color:#001018; font-weight:800; width:100%; }
  .counter{ font-size:56px; font-weight:900; }
  .muted{ color:var(--dim); }
  table{ width:100%; border-collapse:collapse; color:#eaf2ff; }
  th,td{ padding:6px 8px; border-bottom:1px dashed rgba(255,255,255,.12); font-size:13px; text-align:left; }
  th{ color:#9bb3d6; font-weight:700; }
  .rank1{ color:#ffd54a; font-weight:800; }
  .rank2{ color:#c6d7ff; font-weight:800; }
  .rank3{ color:#ffb48a; font-weight:800; }

  /* ===== 十字キー（小さめ）— ステージの“下に配置”して重ならない ===== */
  #controls{
    flex:0 0 auto;
    display:flex; justify-content:center; align-items:center; gap:10px;
    margin-bottom:6px; /* 端末下部UIにかぶらない余白 */
  }
  .dpad{
    width: 132px; height: 132px; display:grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 6px;
    background: rgba(10,12,20,.25);
    border:1px solid rgba(255,255,255,.14);
    border-radius: 14px;
    backdrop-filter: blur(6px);
    touch-action:none;
  }
  .dpad button{
    width:100%; height:100%;
    border-radius:10px;
    background:#1c2334; border:1px solid rgba(255,255,255,.18);
    color:#cfe7ff; font-weight:900; font-size:16px;
    touch-action:none;
  }
  .dpad button:active{ background:#24304a; transform: translateY(1px); }
  .up   { grid-area: 1 / 2; }
  .left { grid-area: 2 / 1; }
  .right{ grid-area: 2 / 3; }
  .down { grid-area: 3 / 2; }
  .legend{
    background: rgba(10,12,20,.35);
    border:1px solid rgba(255,255,255,.15);
    border-radius: 10px;
    padding:4px 8px; font-size:11px; color:#cfe7ff;
  }
</style>
</head>
<body>
<div id="app-wrap">
  <div id="phone" aria-label="MOB balloon - mobile fixed view">
    <!-- 上：バー -->
    <div id="topbar">
      <div>MOB balloon</div>
      <div id="hud">
        <span>R:<b id="roundNum">1</b>/3</span>
        <span>生存:<b id="alive">8</b></span>
        <span>時間:<b id="time">0.0</b>s</span>
        <span id="speedTag">通常</span>
      </div>
    </div>

    <!-- 中央：ステージ + 直下D-Pad（被らない） -->
    <div id="center">
      <div id="stage">
        <canvas id="cv" width="1000" height="1000"></canvas>

        <!-- スタート -->
        <div class="overlay" id="startOverlay">
          <div class="center-panel">
            <div class="title">MOB balloon</div>
            <div class="sub">下の十字キーで移動。カラスから逃げ続けよう！</div>
            <button class="btn" id="btnStart">ゲームスタート</button>
          </div>
        </div>
        <!-- カウント -->
        <div class="overlay" id="countOverlay" style="display:none;">
          <div class="counter" id="countLabel">3</div>
        </div>
        <!-- ラウンド結果（2秒表示） -->
        <div class="overlay" id="roundOverlay" style="display:none;">
          <div class="center-panel" id="roundPanel">
            <div class="title">ラウンド結果</div>
            <div class="sub" id="roundSummary">…</div>
            <table id="roundTable"></table>
            <div class="muted" style="margin-top:8px;">次のラウンドへ移動中…</div>
          </div>
        </div>
        <!-- 総合結果（2秒表示） -->
        <div class="overlay" id="finalOverlay" style="display:none;">
          <div class="center-panel">
            <div class="title">総合結果</div>
            <div class="sub">全3ラウンドの合計ポイント</div>
            <table id="finalTable"></table>
            <div class="muted" style="margin-top:8px;">新しいゲームを開始します…</div>
          </div>
        </div>
      </div>

      <!-- 十字キー（ステージの下・非重なり） -->
      <div id="controls" aria-label="controls">
        <div class="dpad" aria-label="directional pad">
          <button class="up"    data-dir="up">▲</button>
          <button class="left"  data-dir="left">◀</button>
          <button class="right" data-dir="right">▶</button>
          <button class="down"  data-dir="down">▼</button>
        </div>
        <div class="legend">十字キー／PCは矢印キーも可</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ===== 画像（同階層・大文字小文字厳守） ===== */
const ASSETS = {
  bg: "MOBhai.png",
  crowR: "karasu1.png",
  crowL: "karasu2.png",
  balloons: {
    Black: "Blackb.png",
    BlueTypo: "Buleb.png",
    Green: "Greenb.png",
    Purple: "murab.png",
    Orange: "Orangeb.png",
    Pink: "Pinkb.png",
    Red: "Redb.png",
    Yellow: "yellowb.png"
  }
};
const balloonOrder = ["Red","BlueTypo","Green","Purple","Orange","Pink","Yellow","Black"];

/* ===== DOM ===== */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const startOverlay = document.getElementById('startOverlay');
const countOverlay = document.getElementById('countOverlay');
const countLabel = document.getElementById('countLabel');
const roundOverlay = document.getElementById('roundOverlay');
const roundTable = document.getElementById('roundTable');
const roundSummary = document.getElementById('roundSummary');
const finalOverlay = document.getElementById('finalOverlay');
const finalTable = document.getElementById('finalTable');
const roundNumEl = document.getElementById('roundNum');
const aliveEl = document.getElementById('alive');
const timeEl = document.getElementById('time');
const speedTag = document.getElementById('speedTag');
const btnStart = document.getElementById('btnStart');

const STAGE_SIZE = 1000;

/* ===== 進行/スコア ===== */
const MAX_PLAYERS = 8;
const ROUNDS_MAX = 3;
const POINTS_MAP = [15,10,7,5,3,1,0,0];
let roundIndex = 0;
let leaderboard = [];
let images = {};
let ready = false;

/* ===== エンティティ ===== */
class Balloon{
  constructor(id, name, colorKey, isPlayer){
    this.id=id; this.name=name; this.colorKey=colorKey; this.isPlayer=isPlayer;
    this.r=26;
    this.x=0; this.y=0; this.vx=0; this.vy=0; this.ax=0; this.ay=0;
    this.alive=true; this.popping=false; this.popTimer=0; this.timeAlive=0; this.rank=null;
    this.aiTargetAngle = Math.random()*Math.PI*2;
    this.aiChangeT = Math.random()*0.5+0.25; // CPU舵切り
    this.control = {up:false,down:false,left:false,right:false}; // プレイヤー
  }
  reset(x,y){
    this.x=x; this.y=y; this.vx=this.vy=0; this.ax=this.ay=0;
    this.alive=true; this.popping=false; this.popTimer=0; this.timeAlive=0; this.rank=null;
    this.control = {up:false,down:false,left:false,right:false};
  }
}
class Crow{
  constructor(){
    this.x=Math.random()*600+200; this.y=Math.random()*600+200;
    this.vx=0; this.vy=0; this.speed=200; this.size=52; this.dirR=true; // 強め
  }
}

/* ===== 状態 ===== */
let balloons = [];
let crows = [];
let gameTime = 0;
let simSpeed = 1.0;
let playing = false;
let counting = false;
let nextCrowTime = 0;
let crowInterval = 6; // 40s以降は4秒
let ended = false;
let placements = [];
let playerBalloon = null;

/* ===== 入力：十字キー（タッチ/クリック/キーボード） ===== */
const input = {up:false,down:false,left:false,right:false};
function bindDPad(){
  const controls = document.querySelectorAll('.dpad button');
  controls.forEach(btn=>{
    const dir = btn.dataset.dir;
    const set = v=>{ input[dir]=v; if(playerBalloon) playerBalloon.control[dir]=v; };
    const on = e=>{ e.preventDefault(); set(true); };
    const off = e=>{ e.preventDefault(); set(false); };

    // タッチ
    btn.addEventListener('touchstart', on, {passive:false});
    btn.addEventListener('touchend', off);
    btn.addEventListener('touchcancel', off);
    // マウス
    btn.addEventListener('mousedown', on);
    btn.addEventListener('mouseup', off);
    btn.addEventListener('mouseleave', off);
  });
  // 画面外で指が離れた時の保険
  window.addEventListener('touchend', ()=>{ ['up','down','left','right'].forEach(k=>{ input[k]=false; if(playerBalloon) playerBalloon.control[k]=false; }); });
  // キーボード
  window.addEventListener('keydown', e=>{
    if(e.key==="ArrowUp") input.up=true;
    if(e.key==="ArrowDown") input.down=true;
    if(e.key==="ArrowLeft") input.left=true;
    if(e.key==="ArrowRight") input.right=true;
  });
  window.addEventListener('keyup', e=>{
    if(e.key==="ArrowUp") input.up=false;
    if(e.key==="ArrowDown") input.down=false;
    if(e.key==="ArrowLeft") input.left=false;
    if(e.key==="ArrowRight") input.right=false;
  });
}

/* ===== 画像ロード ===== */
function loadImage(src){
  return new Promise((res,rej)=>{
    const img = new Image();
    img.onload=()=>res(img);
    img.onerror=()=>rej(new Error("fail:"+src));
    img.src = src;
  });
}
async function loadAssets(){
  const list = [
    ['bg', ASSETS.bg],
    ['crowR', ASSETS.crowR],
    ['crowL', ASSETS.crowL],
    ['bBlack', ASSETS.balloons.Black],
    ['bBlue', ASSETS.balloons.BlueTypo],
    ['bGreen', ASSETS.balloons.Green],
    ['bPurple', ASSETS.balloons.Purple],
    ['bOrange', ASSETS.balloons.Orange],
    ['bPink', ASSETS.balloons.Pink],
    ['bRed', ASSETS.balloons.Red],
    ['bYellow', ASSETS.balloons.Yellow],
  ];
  const imgs = await Promise.all(list.map(([k,src])=>loadImage(src).then(img=>[k,img])));
  imgs.forEach(([k,img])=>images[k]=img);
  ready = true;
}

/* ===== 色ユーティリティ ===== */
function colorToImageKey(colorKey){
  switch(colorKey){
    case 'Black': return 'bBlack';
    case 'BlueTypo': return 'bBlue';
    case 'Green': return 'bGreen';
    case 'Purple': return 'bPurple';
    case 'Orange': return 'bOrange';
    case 'Pink': return 'bPink';
    case 'Red': return 'bRed';
    case 'Yellow': return 'bYellow';
  }
  return 'bRed';
}
function nameFromColor(colorKey){
  return {Black:'Black', BlueTypo:'Blue', Green:'Green', Purple:'Purple', Orange:'Orange', Pink:'Pink', Red:'Red', Yellow:'Yellow'}[colorKey] || colorKey;
}

/* ===== セットアップ ===== */
function setupPlayers(){
  balloons = [];
  const others = balloonOrder.filter(k=>k!=="Red");
  for (let i=others.length-1;i>0;i--){
    const j = (Math.random()* (i+1))|0;
    [others[i],others[j]]=[others[j],others[i]];
  }
  const allColors = ["Red", ...others.slice(0,7)];
  for(let i=0;i<MAX_PLAYERS;i++){
    const ck = allColors[i];
    const isPlayer = (ck==="Red");
    const b = new Balloon(i, isPlayer? "YOU (Red)":"CPU ("+nameFromColor(ck)+")", ck, isPlayer);
    balloons.push(b);
    if(isPlayer) playerBalloon = b;
  }

  // 横一列（ランダム順）
  const order = [...Array(MAX_PLAYERS).keys()];
  for (let i=order.length-1;i>0;i--){
    const j = (Math.random()* (i+1))|0; [order[i],order[j]]=[order[j],order[i]];
  }
  const y = 150, margin = 80, span = STAGE_SIZE - margin*2;
  order.forEach((idx,k)=>{
    const b = balloons[idx];
    const x = margin + span * (k/(MAX_PLAYERS-1));
    b.reset(x,y);
  });
}
function setupCrows(){
  crows = [];
  const c = new Crow();
  c.x = STAGE_SIZE/2 + (Math.random()*240-120);
  c.y = STAGE_SIZE*0.75 + (Math.random()*100-50);
  crows.push(c);
  nextCrowTime = crowInterval; // 初回増員
}
function resetRound(){
  gameTime = 0; simSpeed = 1.0; playing=false; counting=false; ended=false;
  placements = [];
  setupPlayers();
  setupCrows();
  aliveEl.textContent = MAX_PLAYERS;
  timeEl.textContent = "0.0";
  speedTag.textContent = "通常";
}

/* ===== カウントダウン ===== */
function startCountdown(){
  counting = true;
  startOverlay.style.display="none";
  countOverlay.style.display="grid";
  let seq = [3,2,1,"GO"]; let i=0;
  const tick=()=>{
    countLabel.textContent = seq[i++];
    if(i<seq.length){ setTimeout(tick, 650); }
    else{ setTimeout(()=>{ countOverlay.style.display="none"; playing = true; counting = false; }, 380); }
  };
  tick();
}

/* ===== 物理＆AI ===== */
function step(dt){
  if(!playing) return;

  // プレイヤー死亡 → 高速3倍
  if(playerBalloon && (!playerBalloon.alive || playerBalloon.popping)){
    simSpeed = 3.0; speedTag.textContent = "高速×3";
  }
  dt *= simSpeed;
  gameTime += dt;

  // カラス増員（6秒、40s超は4秒）
  if(gameTime >= nextCrowTime){
    const c = new Crow();
    const edge = Math.random()<0.5 ? 'x' : 'y';
    if(edge==='x'){ c.x = Math.random()<0.5 ? 40 : STAGE_SIZE-40; c.y = Math.random()* (STAGE_SIZE-240)+120; }
    else{ c.x = Math.random()* (STAGE_SIZE-240)+120; c.y = Math.random()<0.5 ? 40 : STAGE_SIZE-40; }
    c.speed = 200 + Math.min(240, gameTime*2.0);
    crows.push(c);
    crowInterval = (gameTime > 40) ? 4 : 6;
    nextCrowTime += crowInterval;
  }

  // サドンデス（60s→1.4倍、90s→1.8倍）
  let sudden = 1.0;
  if(gameTime > 90) sudden = 1.8;
  else if(gameTime > 60) sudden = 1.4;

  // プレイヤー：十字キー加速（さらに速く）
  if(playerBalloon && playerBalloon.alive && !playerBalloon.popping){
    const acc = 700;   // 速度UP
    let ax = (playerBalloon.control.right?1:0) - (playerBalloon.control.left?1:0);
    let ay = (playerBalloon.control.down?1:0) - (playerBalloon.control.up?1:0);
    if(ax||ay){
      const len = Math.hypot(ax,ay) || 1;
      playerBalloon.ax = (ax/len)*acc;
      playerBalloon.ay = (ay/len)*acc;
    }else{
      playerBalloon.ax = playerBalloon.ay = 0;
    }
  }

  // CPU：強め（広範囲回避・高加速）
  balloons.forEach(b=>{
    if(!b.isPlayer && b.alive && !b.popping){
      b.aiChangeT -= dt;
      if(b.aiChangeT<=0){
        let avoidX=0, avoidY=0, nearestD2=1e12, nearDX=0, nearDY=0;
        crows.forEach(c=>{
          const dx = b.x - c.x, dy = b.y - c.y;
          const d2 = dx*dx+dy*dy;
          if(d2< nearestD2){ nearestD2=d2; nearDX=dx; nearDY=dy; }
          if(d2< 340*340){ avoidX += dx; avoidY += dy; }
        });
        // 壁から離れる力
        const m=130, pull=240;
        if(b.x<m) avoidX += pull;
        if(b.x>STAGE_SIZE-m) avoidX -= pull;
        if(b.y<m) avoidY += pull;
        if(b.y>STAGE_SIZE-m) avoidY -= pull;

        const angle = Math.atan2(avoidY,avoidX);
        const err = (Math.random()*0.5-0.25);
        b.aiTargetAngle = isFinite(angle) ? angle + err : Math.atan2(nearDY,nearDX) + Math.PI + err;
        b.aiChangeT = 0.28 + Math.random()*0.2;
      }

      const accCPU = 620; // 強い
      b.ax = Math.cos(b.aiTargetAngle)*accCPU;
      b.ay = Math.sin(b.aiTargetAngle)*accCPU;
    }
  });

  // 速度更新（さらに上げる）
  const drag = 0.93;
  const vmax = 780; // 速度UP
  balloons.forEach(b=>{
    if(!b.alive) return;
    if(b.popping){
      b.popTimer += dt;
      if(b.popTimer>=0.6){ b.alive=false; registerElimination(b); }
      return;
    }
    b.vx = (b.vx + b.ax*dt)*drag;
    b.vy = (b.vy + b.ay*dt)*drag;
    const sp = Math.hypot(b.vx,b.vy);
    if(sp>vmax){ b.vx = b.vx/sp*vmax; b.vy = b.vy/sp*vmax; }
    b.x += b.vx*dt; b.y += b.vy*dt;

    const r = b.r;
    if(b.x<r){ b.x=r; b.vx = Math.abs(b.vx)*0.7; }
    if(b.x>STAGE_SIZE-r){ b.x=STAGE_SIZE-r; b.vx = -Math.abs(b.vx)*0.7; }
    if(b.y<r){ b.y=r; b.vy = Math.abs(b.vy)*0.7; }
    if(b.y>STAGE_SIZE-r){ b.y=STAGE_SIZE-r; b.vy = -Math.abs(b.vy)*0.7; }

    b.timeAlive += dt;
  });

  // 風船同士弾き
  for(let i=0;i<balloons.length;i++){
    const a = balloons[i]; if(!a.alive || a.popping) continue;
    for(let j=i+1;j<balloons.length;j++){
      const b = balloons[j]; if(!b.alive || b.popping) continue;
      const dx=b.x-a.x, dy=b.y-a.y;
      const dist = Math.hypot(dx,dy);
      const min = a.r + b.r;
      if(dist>0 && dist<min){
        const nx = dx/dist, ny=dy/dist;
        const overlap = (min - dist)*0.6;
        a.x -= nx*overlap*0.5; a.y -= ny*overlap*0.5;
        b.x += nx*overlap*0.5; b.y += ny*overlap*0.5;
        const bounce = 160;
        a.vx -= nx*bounce; a.vy -= ny*bounce;
        b.vx += nx*bounce; b.vy += ny*bounce;
      }
    }
  }

  // カラス追尾＆ヒット
  crows.forEach(cr=>{
    let target=null, best=1e9;
    balloons.forEach(b=>{
      if(!b.alive || b.popping) return;
      const dx=b.x-cr.x, dy=b.y-cr.y;
      const d2 = dx*dx+dy*dy;
      if(d2<best){ best=d2; target=b; }
    });
    if(target){
      const dx=target.x-cr.x, dy=target.y-cr.y;
      const dist = Math.hypot(dx,dy)||1;
      const ux=dx/dist, uy=dy/dist;
      const sp = cr.speed * sudden;
      cr.vx = ux*sp; cr.vy=uy*sp;
      cr.x += cr.vx*dt; cr.y += cr.vy*dt;
      cr.dirR = cr.vx>=0;

      // 壁反射
      if(cr.x<30){ cr.x=30; cr.vx = Math.abs(cr.vx); }
      if(cr.x>STAGE_SIZE-30){ cr.x=STAGE_SIZE-30; cr.vx = -Math.abs(cr.vx); }
      if(cr.y<30){ cr.y=30; cr.vy = Math.abs(cr.vy); }
      if(cr.y>STAGE_SIZE-30){ cr.y=STAGE_SIZE-30; cr.vy = -Math.abs(cr.vy); }

      // ヒット
      balloons.forEach(b=>{
        if(!b.alive || b.popping) return;
        const d = Math.hypot(b.x-cr.x, b.y-cr.y);
        if(d < (b.r + cr.size*0.72)){
          b.popping = true; b.popTimer=0;
          const nx = (b.x-cr.x)/(d||1), ny=(b.y-cr.y)/(d||1);
          b.vx += nx*320; b.vy += ny*320;
        }
      });
    }
  });

  // 生存数
  const aliveCount = balloons.filter(b=>b.alive || b.popping).length;
  aliveEl.textContent = aliveCount;

  // ラスト1人で終了
  if(!ended){
    const live = balloons.filter(b=>b.alive && !b.popping);
    const totalLiveOrPop = balloons.filter(b=>b.alive || b.popping).length;
    if(live.length<=1 || totalLiveOrPop<=1){
      const winner = (live[0] || balloons.find(b=>b.alive || b.popping)) || null;
      if(winner && winner.rank==null){ winner.rank = 1; placements.push(winner); }
      endRoundAuto();
    }
  }

  timeEl.textContent = (playerBalloon? playerBalloon.timeAlive : 0).toFixed(1);
}

function registerElimination(b){
  if(b.rank!=null) return;
  placements.push(b);
}

/* ===== 描画 ===== */
function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);
  if(images.bg){ ctx.drawImage(images.bg, 0,0, STAGE_SIZE, STAGE_SIZE); }
  else{ ctx.fillStyle="#0a0e18"; ctx.fillRect(0,0,STAGE_SIZE,STAGE_SIZE); }

  // 枠
  ctx.strokeStyle = "rgba(255,255,255,.15)";
  ctx.lineWidth = 4; ctx.strokeRect(2,2,STAGE_SIZE-4,STAGE_SIZE-4);

  // カラス
  crows.forEach(cr=>{
    const img = cr.dirR ? images.crowR : images.crowL;
    const s = cr.size*2.0;
    if(img) ctx.drawImage(img, cr.x - s*0.5, cr.y - s*0.5, s, s);
    else{ ctx.fillStyle="#000"; ctx.beginPath(); ctx.arc(cr.x,cr.y, cr.size, 0, Math.PI*2); ctx.fill(); }
  });

  // 風船
  balloons.forEach(b=>{
    if(!b.alive && !b.popping) return;
    const key = colorToImageKey(b.colorKey);
    const img = images[key];
    const scale = 2.0;
    if(b.popping){
      const t = Math.min(1, Math.max(0, b.popTimer/0.6));
      const alpha = 1 - t; const blow = 1 + t*0.6;
      ctx.save(); ctx.globalAlpha = alpha;
      const s = b.r*2*scale*blow;
      if(img) ctx.drawImage(img, b.x - s*0.5, b.y - s*0.5, s, s);
      else{ ctx.fillStyle="rgba(255,255,255,"+alpha+")"; ctx.beginPath(); ctx.arc(b.x,b.y,b.r*blow,0,Math.PI*2); ctx.fill(); }
      ctx.restore();
    }else{
      const s = b.r*2*scale;
      if(img) ctx.drawImage(img, b.x - s*0.5, b.y - s*0.5, s, s);
      else{ ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
    }
  });

  if(counting){
    ctx.fillStyle="rgba(0,0,0,.2)";
    ctx.fillRect(0,0,STAGE_SIZE,STAGE_SIZE);
  }
}

/* ===== ラウンド終了 → 2秒表示 → 自動で次へ/最終結果 ===== */
function endRoundAuto(){
  if(ended) return;
  ended = true; playing = false;

  // 保険：未登録の脱落者追加
  balloons.forEach(b=>{
    if((!b.alive && !b.popping) && !placements.includes(b)) placements.push(b);
  });

  const stillAlive = balloons.filter(b=>b.alive || b.popping);
  if(stillAlive.length===1 && !placements.includes(stillAlive[0])){
    stillAlive[0].rank = 1; placements.push(stillAlive[0]);
  }

  const order = placements.slice().reverse(); // 残った順
  order.forEach((b,i)=> b.rank = b.rank ?? (i+1));

  const points = new Map();
  order.forEach(rr=>{
    const p = POINTS_MAP[(rr.rank-1)] || 0;
    points.set(rr.id, p);
    let row = leaderboard.find(x=>x.id===rr.id);
    if(!row){ row = {id:rr.id, name:rr.name, total:0, color:rr.colorKey}; leaderboard.push(row); }
    row.total += p;
  });

  renderRoundTable(order, points);
  roundOverlay.style.display="grid";

  setTimeout(()=>{
    roundOverlay.style.display="none";
    roundIndex++;
    roundNumEl.textContent = Math.min(roundIndex+1, ROUNDS_MAX);
    if(roundIndex >= ROUNDS_MAX){
      showFinalAuto();
    }else{
      resetRound(); startCountdown();
    }
  }, 2000);
}

function renderRoundTable(roundRanks, points){
  const you = roundRanks.find(r=>r.id===playerBalloon.id);
  const tAlive = (playerBalloon?.timeAlive ?? 0).toFixed(1);
  roundSummary.innerHTML = `あなたの順位：<b>${you?.rank ?? '-'}</b> 位　／　生存時間：<b>${tAlive}</b> 秒`;
  roundTable.innerHTML = `
    <tr><th>順位</th><th>名前</th><th>ポイント</th></tr>
    ${ roundRanks.map(r=>{
        const pt = points.get(r.id)||0;
        const cls = r.rank===1?'rank1':(r.rank===2?'rank2':(r.rank===3?'rank3':''));
        return `<tr><td class="${cls}">${r.rank}</td><td>${r.name}</td><td>${pt}</td></tr>`;
      }).join('') }
  `;
}

function showFinalAuto(){
  const sorted = leaderboard.slice().sort((a,b)=>b.total-a.total);
  finalTable.innerHTML = `
    <tr><th>総合</th><th>名前</th><th>合計</th></tr>
    ${ sorted.map((r,i)=>{
        const cls = i===0?'rank1':(i===1?'rank2':(i===2?'rank3':''));
        return `<tr><td class="${cls}">${i+1}</td><td>${r.name}</td><td>${r.total}</td></tr>`;
      }).join('') }
  `;
  finalOverlay.style.display="grid";

  // 2秒後タイトルへ
  setTimeout(()=>{
    finalOverlay.style.display="none";
    leaderboard = []; roundIndex = 0; roundNumEl.textContent = 1;
    startOverlay.style.display="grid";
  }, 2000);
}

/* ===== ループ ===== */
let last=0;
function loop(t){
  if(!ready){ requestAnimationFrame(loop); return; }
  const now = t/1000;
  const dt = Math.min(0.033, now-last || 0.016);
  last = now;
  step(dt);
  draw();
  requestAnimationFrame(loop);
}

/* ===== 初期化 ===== */
bindDPad();
loadAssets().then(()=>{ requestAnimationFrame(loop); }).catch(err=>{
  console.error(err);
  alert("画像の読み込みに失敗しました。ファイル名の大文字/小文字と配置を確認してください。");
});

/* ===== スクロール/ジェスチャ抑止（iOS向け） ===== */
document.addEventListener('gesturestart', e=>e.preventDefault(), {passive:false});
document.addEventListener('touchmove', e=>{
  if(e.target.closest('.dpad') || e.target.closest('#stage')) e.preventDefault();
},{passive:false});

/* ===== スタート ===== */
btnStart.addEventListener('click', ()=>{ resetRound(); startCountdown(); });
</script>
</body>
</html>
