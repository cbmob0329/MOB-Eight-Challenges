<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>Hockey Charge Fly</title>
<style>
  :root{
    --ui-bg:#0b0d12; --ui-fg:#fff; --ui-dim:#9aa3b2; --accent:#26d0ff; --accent2:#ff5a8a;
  }
  html,body{margin:0;height:100%;background:#000;color:var(--ui-fg);font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Sans","Noto Sans JP",sans-serif}
  /* 100vh対策（iOS Safari） */
  #app{position:fixed;inset:0;display:flex;flex-direction:column;background:#000}
  #safe{position:relative;flex:1;padding-top:env(safe-area-inset-top);padding-bottom:env(safe-area-inset-bottom)}
  #game{position:absolute;inset:0;display:block;width:100%;height:100%;touch-action:none;background:#000}
  /* オーバーレイUI */
  .overlay{position:fixed;left:0;right:0;display:flex;justify-content:center;pointer-events:none}
  .top{top:calc(env(safe-area-inset-top) + 6px)}
  .center{top:0;bottom:0;align-items:center}
  .bottom{bottom:calc(env(safe-area-inset-bottom) + 14px)}
  .msg{
    background:rgba(10,12,18,.75);backdrop-filter:blur(6px);
    padding:10px 14px;border:1px solid rgba(255,255,255,.2);border-radius:12px;
    font-weight:700;letter-spacing:.02em;box-shadow:0 6px 24px rgba(0,0,0,.35)
  }
  .big{font-size:28px}
  .mid{font-size:20px}
  .small{font-size:14px;color:var(--ui-dim)}
  .distance{
    background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.18);
    border-radius:999px;padding:6px 12px;font-weight:700
  }
  /* リスタートボタン */
  #restart{
    position:fixed;left:50%;transform:translateX(-50%);
    bottom:calc(env(safe-area-inset-bottom) + 18px);
    background:linear-gradient(180deg,#1f2632,#0f141c);
    color:#fff;border:1px solid #2e394b;border-radius:14px;padding:12px 18px;
    font-weight:700;letter-spacing:.03em;box-shadow:0 10px 28px rgba(0,0,0,.4);
    display:none
  }
  #restart:active{transform:translateX(-50%) scale(.98)}
  /* ゲージ説明（上部） */
  #hint{display:none}
  /* ランキング表 */
  #board{
    position:fixed;left:12px;right:12px;top:50%;transform:translateY(-50%);
    background:rgba(9,11,16,.82);backdrop-filter:blur(8px);
    border:1px solid rgba(255,255,255,.15);border-radius:16px;padding:14px;
    display:none;pointer-events:none
  }
  #board h3{margin:0 0 8px 0;font-size:18px}
  #board ol{margin:0;padding-left:18px}
  #board li{margin:6px 0}
</style>
</head>
<body>
<div id="app">
  <div id="safe">
    <canvas id="game"></canvas>
  </div>
</div>

<!-- オーバーレイ表示 -->
<div class="overlay center" id="intro"><div class="msg big">パワーを溜めて遠くまで飛ばせ！</div></div>
<div class="overlay top" id="hint"><div class="msg small">左列 上→中→下 → 次に右列 上→中→下（右列は難しい）</div></div>
<div class="overlay center" id="chargeDone"><div class="msg big">チャージ完了！</div></div>
<div class="overlay center" id="countdown"><div class="msg big" id="cdText"></div></div>
<div class="overlay top" id="distanceWrap"><div class="distance" id="distText">0.0 m</div></div>
<div class="overlay center" id="record"><div class="msg big" id="recordText">記録 0.0 m！</div></div>

<button id="restart">リスタート</button>

<div id="board">
  <h3>順位発表</h3>
  <ol id="rankList"></ol>
</div>

<script>
(() => {
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));
  let W=0,H=0;

  // 画像
  const bgImg = new Image(); bgImg.src = 'hoke.png';
  const ballImg = new Image(); ballImg.src = 'red.png';

  // ステート
  const State = {
    INTRO:'intro', GAUGE:'gauge', CHARGE_DONE:'chargeDone',
    COUNTDOWN:'countdown', FLYING:'flying', STOPPED:'stopped',
    RESULTS:'results', IDLE:'idle'
  };
  let state = State.INTRO;

  // UI要素
  const show = (el, on) => { el.style.display = on ? '' : 'none'; };
  const $intro = document.getElementById('intro');
  const $hint = document.getElementById('hint');
  const $done = document.getElementById('chargeDone');
  const $cd = document.getElementById('countdown');
  const $cdText = document.getElementById('cdText');
  const $distWrap = document.getElementById('distanceWrap');
  const $distText = document.getElementById('distText');
  const $record = document.getElementById('record');
  const $recordText = document.getElementById('recordText');
  const $restart = document.getElementById('restart');
  const $board = document.getElementById('board');
  const $rankList = document.getElementById('rankList');

  // レイアウト & リサイズ
  function fit(){
    const rect = cvs.getBoundingClientRect();
    W = Math.floor(rect.width * DPR);
    H = Math.floor(rect.height * DPR);
    cvs.width = W; cvs.height = H;
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
  }
  addEventListener('resize', fit, {passive:true});
  fit();

  // 背景スケール・ループ
  let bgScale=1, bgW=0, bgH=0;
  function updateBgScale(){
    if (!bgImg.complete || !bgImg.naturalWidth) return;
    // 画面に収まるようフィット（cover寄りだが縦ループ前提）
    const sw = bgImg.naturalWidth, sh = bgImg.naturalHeight;
    const scale = Math.max(W/sw, H/sh); // 画面全体を覆う
    bgScale = scale;
    bgW = sw*scale; bgH = sh*scale;
  }
  bgImg.onload = updateBgScale;

  // ======= ゲージ関連 =======
  const gauges = []; // 6本（左3→右3）
  const gaugeOrder = [
    {col:0,row:0},{col:0,row:1},{col:0,row:2},
    {col:1,row:0},{col:1,row:1},{col:1,row:2}
  ];
  let currentGaugeIndex = 0;

  function initGauges(){
    gauges.length = 0;
    for(let i=0;i<6;i++){
      const isRight = i>=3;
      gauges.push({
        value: Math.random(), dir: 1,
        speed: isRight ? 1.2 : 0.8, // 右は速い＝難しい
        locked: false
      });
    }
    currentGaugeIndex = 0;
  }

  function drawGauges(){
    // 画面中央に2列×3行の縦ゲージ
    const totalW = Math.min(W*0.9, 520*DPR);
    const colGap = 48*DPR, rowGap = 22*DPR;
    const gaugeW = 30*DPR;
    const gaugeH = Math.min(H*0.6, 360*DPR);
    const areaW = gaugeW*2 + colGap;
    const startX = (W - areaW)/2;
    const startY = (H - (gaugeH*3 + rowGap*2))/2;

    for(let i=0;i<6;i++){
      const col = i<3 ? 0 : 1;
      const row = i%3;
      const x = startX + col*(gaugeW + colGap);
      const y = startY + row*(gaugeH + rowGap);

      // 背板
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      roundRect(ctx, x, y, gaugeW, gaugeH, 12*DPR);
      ctx.fill();

      // メーター導線
      const pad = 6*DPR;
      const innerX = x+pad, innerY = y+pad, innerW = gaugeW-pad*2, innerH = gaugeH-pad*2;
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      roundRect(ctx, innerX, innerY, innerW, innerH, 8*DPR);
      ctx.fill();

      // 判定スイートゾーン（右列ほど狭い）
      const sweet = (i>=3) ? 0.22 : 0.32;
      const sweetH = innerH * sweet;
      const sweetY = innerY + innerH*(0.5 - sweet/2);
      ctx.fillStyle = 'rgba(38,208,255,0.22)';
      roundRect(ctx, innerX+2*DPR, sweetY, innerW-4*DPR, sweetH, 6*DPR);
      ctx.fill();

      // 現在位置バー
      const g = gauges[i];
      const cy = innerY + (1-g.value)*innerH;
      ctx.fillStyle = g.locked ? 'rgba(255,90,138,0.9)' : 'rgba(255,255,255,0.9)';
      roundRect(ctx, innerX+3*DPR, cy-4*DPR, innerW-6*DPR, 8*DPR, 4*DPR);
      ctx.fill();

      // 枠＆番号
      ctx.strokeStyle = (i===currentGaugeIndex) ? '#26d0ff' : 'rgba(255,255,255,0.28)';
      ctx.lineWidth = (i===currentGaugeIndex) ? 3*DPR : 1*DPR;
      roundRect(ctx, x, y, gaugeW, gaugeH, 12*DPR);
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.font = `${12*DPR}px system-ui, sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'top';
      ctx.fillText(`${i+1}`, x+gaugeW/2, y-18*DPR);
    }
  }

  function updateGauges(dt){
    for(let i=0;i<6;i++){
      const g = gauges[i];
      if (g.locked) continue;
      // 現在操作中のゲージのみ動かす
      if (i!==currentGaugeIndex) continue;
      g.value += g.dir * g.speed * dt * 0.5;
      if (g.value>1){ g.value=1; g.dir=-1; }
      if (g.value<0){ g.value=0; g.dir=1; }
    }
  }

  function stopCurrentGauge(){
    const g = gauges[currentGaugeIndex];
    if (!g || g.locked) return;
    g.locked = true;
    currentGaugeIndex++;
    if (currentGaugeIndex>=6){
      // 全確定 → チャージ完了
      beginChargeDone();
    }
  }

  // ======= 飛行関連 =======
  let ball = null;
  let camY = 0;      // カメラのスクロール量（上向き）
  let bgScroll = 0;  // 背景描画用オフセット
  let totalDist = 0; // m
  let countdownT = 0;
  let introTimer = 0;
  let doneTimer = 0;
  let recordTimer = 0;
  let resultsTimer = 0;

  function initBall(){
    const radius = Math.round(Math.min(W,H)*0.045);
    ball = {
      x: W/2,
      y: H*0.72,
      r: radius,
      vy: 0,
      shaking: false
    };
    camY = 0; bgScroll = 0; totalDist = 0;
  }

  function chargePower(){
    // 左列は「甘め」、右列は「難しい」＝スイートゾーン中心に近いほど高評価に
    // value: 0..1（上=1）
    let score = 0;
    for(let i=0;i<6;i++){
      const v = gauges[i].value;
      const center = 0.5;
      const diff = Math.abs(v - center);
      const tight = (i>=3) ? 0.20 : 0.30; // 右は狭い
      const unit = Math.max(0, 1 - diff/(tight));
      // 右列は重みアップ
      const weight = (i>=3) ? 1.25 : 1.0;
      score += unit * weight;
    }
    // 最大理論値 = 左:3*1.0 + 右:3*1.25 = 6.75
    const norm = Math.min(1, score / 6.75);
    // 初速度（上）m/s的な仮値（画面スケールに合わせる）
    const v0 = (H * 0.9) * (0.75 + 1.1*norm); // 画面高ベース
    return v0;
  }

  function beginIntro(){
    state = State.INTRO;
    show($intro,true); show($hint,false); show($done,false); show($cd,false);
    show($distWrap,false); show($record,false); $restart.style.display='none'; $board.style.display='none';
    introTimer = 2.0;
    initGauges();
    initBall();
  }

  function beginGauge(){
    state = State.GAUGE;
    show($intro,false); show($hint,true);
  }

  function beginChargeDone(){
    state = State.CHARGE_DONE;
    show($hint,false); show($done,true);
    doneTimer = 2.0;
    // 初速度計算だけ先に
    launchV0 = chargePower();
  }

  function beginCountdown(){
    state = State.COUNTDOWN;
    show($done,false); show($cd,true);
    countdownT = 3.2; // 3→2→1→GO
    ball.shaking = true;
  }

  function beginFlying(){
    state = State.FLYING;
    show($cd,false); show($distWrap,true);
    ball.shaking = false;
    ball.vy = -launchV0; // 上方向を負で扱う
  }

  function stopAndRecord(){
    state = State.STOPPED;
    show($distWrap,false);
    show($record,true);
    $recordText.textContent = `記録 ${totalDist.toFixed(1)} m！`;
    recordTimer = 2.0;
  }

  function showResults(){
    state = State.RESULTS;
    show($record,false);
    const cpu = makeCPUResults(totalDist);
    // ランキング生成
    const all = [{name:'あなた', d:totalDist, you:true}, ...cpu];
    all.sort((a,b)=>b.d-a.d);
    let idx = 1, html='';
    for(const r of all){
      const mark = r.you ? '👑' : '';
      html += `<li>${idx}. ${r.you?'<b>あなた</b>':`CPU${r.id}`} — <b>${r.d.toFixed(1)} m</b> ${mark}</li>`;
      idx++;
    }
    $rankList.innerHTML = html;
    $board.style.display = '';
    resultsTimer = 3.0;
  }

  function showRestart(){
    $restart.style.display = 'block';
  }

  function makeCPUResults(playerDist){
    // プレイヤーを中心に±20%程度で4人作成
    const arr = [];
    for(let i=1;i<=4;i++){
      const delta = (Math.random()*0.4 - 0.2); // -20%..+20%
      const d = Math.max(5, playerDist * (1 + delta));
      arr.push({id:i, d});
    }
    return arr;
  }

  // 入力
  function onTap(){
    if (state===State.GAUGE){
      stopCurrentGauge();
    }
  }
  cvs.addEventListener('pointerdown', onTap);

  // リスタート
  $restart.addEventListener('click', ()=>{
    beginIntro();
  });

  // メインループ
  let last = performance.now();
  let launchV0 = 0;

  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    updateBgScale();
    ctx.clearRect(0,0,W,H);

    // 背景描画（縦ループ）
    drawBg();

    switch(state){
      case State.INTRO:
        drawBallAtRest();
        introTimer -= dt;
        if (introTimer<=0) beginGauge();
        break;

      case State.GAUGE:
        updateGauges(dt);
        drawGauges();
        drawBallAtRest();
        break;

      case State.CHARGE_DONE:
        drawBallAtRest();
        doneTimer -= dt;
        if (doneTimer<=0) beginCountdown();
        break;

      case State.COUNTDOWN:
        // 震えアニメ
        drawBallAtRest(true);
        countdownT -= dt;
        renderCountdown(countdownT);
        if (countdownT<=0) beginFlying();
        break;

      case State.FLYING:
        updateFlight(dt);
        drawFlight();
        break;

      case State.STOPPED:
        drawFlight(true);
        recordTimer -= dt;
        if (recordTimer<=0) showResults();
        break;

      case State.RESULTS:
        drawFlight(true);
        resultsTimer -= dt;
        if (resultsTimer<=0) showRestart();
        break;
    }

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ======= 描画ヘルパ =======
  function drawBg(){
    if (!bgW || !bgH){ ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H); return; }
    // カメラYに合わせて下方向へ流す（ボール上昇の見た目）
    // オフセットを正方向で増やし、テクスチャを下から上へ送る
    const offset = (bgScroll % bgH + bgH) % bgH;
    // 2枚でシームレス
    ctx.drawImage(bgImg, 0, -offset, bgW, bgH);
    ctx.drawImage(bgImg, 0, -offset + bgH, bgW, bgH);
    // 余白が出ないよう横整列（中央寄せ）
    // 既に bgW==W になるように scale 設定しているが、微小誤差は塗りで隠す
    if (bgW<W){
      ctx.fillStyle='#000';
      const pad = Math.floor((W-bgW)/2);
      ctx.fillRect(0,0,pad,H); ctx.fillRect(W-pad,0,pad,H);
    }
  }

  function drawBallAtRest(shake=false){
    const x = ball.x;
    const y = ball.y;
    let dx=0, dy=0;
    if (shake){
      dx = (Math.random()*2-1) * ball.r*0.08;
      dy = (Math.random()*2-1) * ball.r*0.08;
    }
    drawBall(x+dx, y+dy, ball.r);
  }

  function drawBall(x,y,r){
    if (ballImg.complete && ballImg.naturalWidth){
      const scale = (r*2)/Math.max(ballImg.naturalWidth, ballImg.naturalHeight);
      const w = ballImg.naturalWidth*scale;
      const h = ballImg.naturalHeight*scale;
      ctx.drawImage(ballImg, x-w/2, y-h/2, w, h);
    }else{
      ctx.fillStyle='#e33';
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    }
  }

  function renderCountdown(t){
    let text='';
    if (t>2) text='3';
    else if (t>1) text='2';
    else if (t>0) text='1';
    else text='GO!';
    $cdText.textContent = text;
  }

  function updateFlight(dt){
    // 簡易物理：上向き負、重力は正
    const g = H * 0.9; // 画面高基準の重力感
    // 空気抵抗的な減衰
    const drag = 0.12;
    ball.vy += g * dt;      // 加速度（下向き）
    ball.vy += ball.vy * drag * dt; // 減衰（上向きの速度を早く失わせる）
    ball.y += ball.vy * dt;

    // カメラ追従：ボールが画面下60%より上に来たら上方向へスクロール
    const followY = H*0.4;
    if (ball.y < followY){
      const dy = followY - ball.y;
      ball.y += dy;
      camY += dy;
      bgScroll += dy; // 背景も同量だけ流す（縦ループ）
      totalDist += dy / (100*DPR); // m換算（適度にスケール）
      // 距離表示更新
      $distText.textContent = `${totalDist.toFixed(1)} m`;
    }

    // 頂点で停止：上向き（vy<0）から下向きへ転じた瞬間に終了
    if (ball.vy >= 0){
      ball.vy = 0;
      stopAndRecord();
    }
  }

  function drawFlight(freeze=false){
    // ボール描画
    drawBall(ball.x, ball.y, ball.r);

    // 距離表示位置（ボールと被らないように中央やや上、距離UIはDOMで位置固定）
    // DOMの距離バッジは画面上部センター固定。ボールが重なる場合はDOMを少し下げたいが、
    // 重なり回避として十分余白（上部）に配置しているためここでは省略。

    if (freeze){
      // 停止中は軽いハイライト
      ctx.strokeStyle='rgba(255,255,255,0.35)';
      ctx.lineWidth = 2*DPR;
      ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r*1.25, 0, Math.PI*2); ctx.stroke();
    }
  }

  // 角丸矩形
  function roundRect(c, x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
  }

  // ゲーム開始
  let started = false;
  function kickstart(){
    if (started) return;
    started = true;
    beginIntro();
  }
  document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState==='visible') fit(); });
  window.addEventListener('load', kickstart);

  // タイマー的に遷移
  function stepTimers(dt){
    if (state===State.INTRO){
      // handled in loop
    } else if (state===State.COUNTDOWN){
      // handled in loop
    }
  }

  // メイン開始済み
})();
</script>
</body>
</html>
