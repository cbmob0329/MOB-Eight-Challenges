<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>Hockey Charge Fly</title>
<style>
  :root{
    --ui-bg:#0b0d12; --ui-fg:#fff; --ui-dim:#9aa3b2; --accent:#26d0ff; --accent2:#ff5a8a;
  }
  html,body{margin:0;height:100%;background:#000;color:var(--ui-fg);font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Sans","Noto Sans JP",sans-serif}
  #app{position:fixed;inset:0;display:flex;flex-direction:column;background:#000}
  #safe{position:relative;flex:1;padding-top:env(safe-area-inset-top);padding-bottom:env(safe-area-inset-bottom)}
  #game{position:absolute;inset:0;display:block;width:100%;height:100%;touch-action:none;background:#000}

  .overlay{position:fixed;left:0;right:0;display:flex;justify-content:center;pointer-events:none}
  .top{top:calc(env(safe-area-inset-top) + 6px)}
  .center{top:0;bottom:0;align-items:center}
  .bottom{bottom:calc(env(safe-area-inset-bottom) + 14px)}
  .msg{
    background:rgba(10,12,18,.75);backdrop-filter:blur(6px);
    padding:10px 14px;border:1px solid rgba(255,255,255,.2);border-radius:12px;
    font-weight:700;letter-spacing:.02em;box-shadow:0 6px 24px rgba(0,0,0,.35)
  }
  .big{font-size:28px}
  .mid{font-size:20px}
  .small{font-size:14px;color:var(--ui-dim)}
  .distance{
    background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.18);
    border-radius:999px;padding:6px 12px;font-weight:700
  }
  #restart{
    position:fixed;left:50%;transform:translateX(-50%);
    bottom:calc(env(safe-area-inset-bottom) + 18px);
    background:linear-gradient(180deg,#1f2632,#0f141c);
    color:#fff;border:1px solid #2e394b;border-radius:14px;padding:12px 18px;
    font-weight:700;letter-spacing:.03em;box-shadow:0 10px 28px rgba(0,0,0,.4);
    display:none
  }
  #restart:active{transform:translateX(-50%) scale(.98)}
  #hint{display:none}

  #board{
    position:fixed;left:12px;right:12px;top:50%;transform:translateY(-50%);
    background:rgba(9,11,16,.82);backdrop-filter:blur(8px);
    border:1px solid rgba(255,255,255,.15);border-radius:16px;padding:14px;
    display:none;pointer-events:none
  }
  #board h3{margin:0 0 8px 0;font-size:18px}
  #board ol{margin:0;padding-left:18px}
  #board li{margin:6px 0}
</style>
</head>
<body>
<div id="app">
  <div id="safe">
    <canvas id="game"></canvas>
  </div>
</div>

<!-- オーバーレイ表示 -->
<div class="overlay center" id="intro"><div class="msg big">パワーを溜めて遠くまで飛ばせ！</div></div>
<div class="overlay top" id="hint"><div class="msg small">横長ゲージ：左列 上→中→下 → 次に右列 上→中→下（右列は超速で難しい）</div></div>
<div class="overlay center" id="chargeDone"><div class="msg big">チャージ完了！</div></div>
<div class="overlay center" id="countdown"><div class="msg big" id="cdText"></div></div>
<div class="overlay top" id="distanceWrap"><div class="distance" id="distText">0.0 m</div></div>
<div class="overlay center" id="record"><div class="msg big" id="recordText">記録 0.0 m！</div></div>

<button id="restart">リスタート</button>

<div id="board">
  <h3>順位発表</h3>
  <ol id="rankList"></ol>
</div>

<script>
(() => {
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));
  let W=0,H=0;

  // 画像
  const bgImg = new Image(); bgImg.src = 'hoke.png';
  const ballImg = new Image(); ballImg.src = 'red.png';

  // ステート
  const State = {
    INTRO:'intro', GAUGE:'gauge', CHARGE_DONE:'chargeDone',
    COUNTDOWN:'countdown', FLYING:'flying', STOPPED:'stopped',
    RESULTS:'results'
  };
  let state = State.INTRO;

  // UI要素
  const show = (el, on) => { el.style.display = on ? '' : 'none'; };
  const $intro = document.getElementById('intro');
  const $hint = document.getElementById('hint');
  const $done = document.getElementById('chargeDone');
  const $cd = document.getElementById('countdown');
  const $cdText = document.getElementById('cdText');
  const $distWrap = document.getElementById('distanceWrap');
  const $distText = document.getElementById('distText');
  const $record = document.getElementById('record');
  const $recordText = document.getElementById('recordText');
  const $restart = document.getElementById('restart');
  const $board = document.getElementById('board');
  const $rankList = document.getElementById('rankList');

  // レイアウト & リサイズ
  function fit(){
    const rect = cvs.getBoundingClientRect();
    W = Math.floor(rect.width * DPR);
    H = Math.floor(rect.height * DPR);
    cvs.width = W; cvs.height = H;
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
  }
  addEventListener('resize', fit, {passive:true});
  fit();

  // 背景スケール・ループ
  let bgW=0, bgH=0;
  function updateBgScale(){
    if (!bgImg.complete || !bgImg.naturalWidth) return;
    const sw = bgImg.naturalWidth, sh = bgImg.naturalHeight;
    const scale = Math.max(W/sw, H/sh);
    bgW = sw*scale; bgH = sh*scale;
  }
  bgImg.onload = updateBgScale;

  // ======= ゲージ（横長×6：縦3行×横2列） =======
  const gauges = [];
  const gaugeOrder = [
    {col:0,row:0},{col:0,row:1},{col:0,row:2}, // 左列 上→中→下
    {col:1,row:0},{col:1,row:1},{col:1,row:2}  // 右列 上→中→下
  ];
  let currentGaugeIndex = 0;

  function initGauges(){
    gauges.length = 0;
    for(let i=0;i<6;i++){
      const isRight = i>=3;
      gauges.push({
        value: Math.random(), dir: 1,             // 0..1（左→右）
        speed: isRight ? 3.2 : 1.8,               // ★ 大幅高速化（右は超速）
        locked: false
      });
    }
    currentGaugeIndex = 0;
  }

  function drawGauges(){
    // 2列×3行の「横長」ゲージを中央に配置
    const totalW = Math.min(W*0.94, 640*DPR);
    const totalH = Math.min(H*0.62, 380*DPR);
    const colGap = 34*DPR, rowGap = 16*DPR;
    const colW = (totalW - colGap)/2;
    const rowH = (totalH - rowGap*2)/3;

    const areaX = (W - totalW)/2;
    const areaY = (H - totalH)/2;

    for(let i=0;i<6;i++){
      const col = i<3 ? 0 : 1;
      const row = i%3;
      const x = areaX + col*(colW + colGap);
      const y = areaY + row*(rowH + rowGap);

      // 背板
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      roundRect(ctx, x, y, colW, rowH, 12*DPR);
      ctx.fill();

      const pad = 8*DPR;
      const innerX = x+pad, innerY = y+pad, innerW = colW-pad*2, innerH = rowH-pad*2;
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      roundRect(ctx, innerX, innerY, innerW, innerH, 8*DPR);
      ctx.fill();

      // 中央スイートゾーン（右列は狭い）
      const sweet = (i>=3) ? 0.20 : 0.30;
      const sweetW = innerW * sweet;
      const sweetX = innerX + innerW*(0.5 - sweet/2);
      ctx.fillStyle = 'rgba(38,208,255,0.22)';
      roundRect(ctx, sweetX, innerY+2*DPR, sweetW, innerH-4*DPR, 6*DPR);
      ctx.fill();

      // 現在位置カーソル（高速でも視認しやすい細スライダー）
      const g = gauges[i];
      const cx = innerX + g.value*innerW;
      const cursorW = 6*DPR;
      const cursorH = innerH - 6*DPR;
      ctx.fillStyle = g.locked ? 'rgba(255,90,138,0.95)' : 'rgba(255,255,255,0.95)';
      roundRect(ctx, cx - cursorW/2, innerY+3*DPR, cursorW, cursorH, 4*DPR);
      ctx.fill();

      // 枠＆番号
      ctx.strokeStyle = (i===currentGaugeIndex) ? '#26d0ff' : 'rgba(255,255,255,0.28)';
      ctx.lineWidth = (i===currentGaugeIndex) ? 3*DPR : 1*DPR;
      roundRect(ctx, x, y, colW, rowH, 12*DPR);
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.font = `${12*DPR}px system-ui, sans-serif`;
      ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
      ctx.fillText(`${i+1}`, x+4*DPR, y-4*DPR);
    }
  }

  function updateGauges(dt){
    for(let i=0;i<6;i++){
      const g = gauges[i];
      if (g.locked || i!==currentGaugeIndex) continue;
      // ★ 超高速往復
      g.value += g.dir * g.speed * dt * 1.1;
      if (g.value>1){ g.value=1; g.dir=-1; }
      if (g.value<0){ g.value=0; g.dir=1; }
    }
  }

  function stopCurrentGauge(){
    const g = gauges[currentGaugeIndex];
    if (!g || g.locked) return;
    g.locked = true;
    currentGaugeIndex++;
    if (currentGaugeIndex>=6){
      beginChargeDone();
    }
  }

  // ======= 飛行（完全に上方向のみ＝落下ゼロの見た目） =======
  let ball = null;
  let anchorY = 0;     // 画面内でボールを固定する高さ
  let bgScroll = 0;    // 背景の縦オフセット（上へ進むほど増える）
  let totalDist = 0;   // m
  let countdownT = 0;
  let introTimer = 0;
  let doneTimer = 0;
  let recordTimer = 0;
  let resultsTimer = 0;
  let launchSpeed = 0; // 正の値（上方向の見た目の速度）

  function initBall(){
    const radius = Math.round(Math.min(W,H)*0.045);
    ball = { x: W/2, y: H*0.72, r: radius };
    anchorY = Math.round(H * 0.40); // 画面上側40%あたりに固定表示
    bgScroll = 0; totalDist = 0;
  }

  function chargePower(){
    // 中央寄せほど高評価、右列に重み
    let score = 0;
    for(let i=0;i<6;i++){
      const v = gauges[i].value;
      const center = 0.5;
      const diff = Math.abs(v - center);
      const tight = (i>=3) ? 0.20 : 0.30;
      const unit = Math.max(0, 1 - diff/(tight));
      const weight = (i>=3) ? 1.25 : 1.0;
      score += unit * weight;
    }
    const norm = Math.min(1, score / 6.75);
    // 初期上昇速度（画面スケール基準の正値）
    const s0 = (H * 1.25) * (0.65 + 1.25*norm);
    return s0;
  }

  function beginIntro(){
    state = State.INTRO;
    show($intro,true); show($hint,false); show($done,false); show($cd,false);
    show($distWrap,false); show($record,false); $restart.style.display='none'; $board.style.display='none';
    introTimer = 2.0;
    initGauges();
    initBall();
  }

  function beginGauge(){
    state = State.GAUGE;
    show($intro,false); show($hint,true);
  }

  function beginChargeDone(){
    state = State.CHARGE_DONE;
    show($hint,false); show($done,true);
    doneTimer = 2.0;
    launchSpeed = chargePower(); // 正値（上へ）
  }

  function beginCountdown(){
    state = State.COUNTDOWN;
    show($done,false); show($cd,true);
    countdownT = 3.2; // 3→2→1→GO
  }

  function beginFlying(){
    state = State.FLYING;
    show($cd,false); show($distWrap,true);
    // ボールの表示位置を固定（以後 ball.y は固定で動かさない）
    ball.y = anchorY;
  }

  function stopAndRecord(){
    state = State.STOPPED;
    show($distWrap,false);
    show($record,true);
    $recordText.textContent = `記録 ${totalDist.toFixed(1)} m！`;
    recordTimer = 2.0;
  }

  function showResults(){
    state = State.RESULTS;
    show($record,false);
    const cpu = makeCPUResults(totalDist);
    const all = [{name:'あなた', d:totalDist, you:true}, ...cpu];
    all.sort((a,b)=>b.d-a.d);
    let idx = 1, html='';
    for(const r of all){
      const mark = r.you ? '👑' : '';
      html += `<li>${idx}. ${r.you?'<b>あなた</b>':`CPU${r.id}`} — <b>${r.d.toFixed(1)} m</b> ${mark}</li>`;
      idx++;
    }
    $rankList.innerHTML = html;
    $board.style.display = '';
    resultsTimer = 3.0;
  }

  function showRestart(){ $restart.style.display = 'block'; }

  function makeCPUResults(playerDist){
    const arr = [];
    for(let i=1;i<=4;i++){
      const delta = (Math.random()*0.4 - 0.2);
      const d = Math.max(5, playerDist * (1 + delta));
      arr.push({id:i, d});
    }
    return arr;
  }

  // 入力
  function onTap(){
    if (state===State.GAUGE) stopCurrentGauge();
  }
  cvs.addEventListener('pointerdown', onTap);
  $restart.addEventListener('click', ()=>{ beginIntro(); });

  // メインループ
  let last = performance.now();

  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    updateBgScale();
    ctx.clearRect(0,0,W,H);

    drawBg(); // 背景

    switch(state){
      case State.INTRO:
        drawBall(ball.x, ball.y, Math.round(Math.min(W,H)*0.045)); // 待機中は足元に
        introTimer -= dt;
        if (introTimer<=0) beginGauge();
        break;

      case State.GAUGE:
        updateGauges(dt);
        drawGauges();
        drawBall(ball.x, ball.y, Math.round(Math.min(W,H)*0.045));
        break;

      case State.CHARGE_DONE:
        drawBall(ball.x, ball.y, Math.round(Math.min(W,H)*0.045));
        doneTimer -= dt;
        if (doneTimer<=0) beginCountdown();
        break;

      case State.COUNTDOWN:
        // 小刻みな震え演出（表示位置固定のまま）
        drawBallShaking(ball.x, ball.y, Math.round(Math.min(W,H)*0.045));
        countdownT -= dt;
        renderCountdown(countdownT);
        if (countdownT<=0) beginFlying();
        break;

      case State.FLYING:
        updateFlight(dt);
        drawBall(ball.x, anchorY, Math.round(Math.min(W,H)*0.045)); // 常に固定位置
        break;

      case State.STOPPED:
        drawBall(ball.x, anchorY, Math.round(Math.min(W,H)*0.045));
        recordTimer -= dt;
        if (recordTimer<=0) showResults();
        break;

      case State.RESULTS:
        drawBall(ball.x, anchorY, Math.round(Math.min(W,H)*0.045));
        resultsTimer -= dt;
        if (resultsTimer<=0) showRestart();
        break;
    }

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ======= 背景／ボール描画 =======
  function drawBg(){
    if (!bgW || !bgH){ ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H); return; }
    const offset = (bgScroll % bgH + bgH) % bgH;
    // 上へ進む＝背景が下から上へ流れる見た目
    ctx.drawImage(bgImg, 0, -offset,           bgW, bgH);
    ctx.drawImage(bgImg, 0, -offset + bgH,     bgW, bgH);
    if (bgW<W){
      ctx.fillStyle='#000';
      const pad = Math.floor((W-bgW)/2);
      ctx.fillRect(0,0,pad,H); ctx.fillRect(W-pad,0,pad,H);
    }
  }

  function drawBall(x,y,r){
    if (ballImg.complete && ballImg.naturalWidth){
      const scale = (r*2)/Math.max(ballImg.naturalWidth, ballImg.naturalHeight);
      const w = ballImg.naturalWidth*scale;
      const h = ballImg.naturalHeight*scale;
      ctx.drawImage(ballImg, x-w/2, y-h/2, w, h);
    }else{
      ctx.fillStyle='#e33';
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    }
  }
  function drawBallShaking(x,y,r){
    const dx = (Math.random()*2-1) * r*0.08;
    const dy = (Math.random()*2-1) * r*0.08;
    drawBall(x+dx, y+dy, r);
  }

  // カウントダウンUI
  function renderCountdown(t){
    let text='';
    if (t>2) text='3';
    else if (t>1) text='2';
    else if (t>0) text='1';
    else text='GO!';
    document.getElementById('cdText').textContent = text;
  }

  // ★ 完全上方向：ボールは固定、背景だけ流す（落下演出ゼロ）
  //    速度は指数的に減衰し、一定以下になったら記録。
  function updateFlight(dt){
    // 速度（正の値）を減衰
    const decay = 0.32;                // 減衰率（上げると早く減る）
    const minSpeed = 28 * DPR;         // 記録判定の下限（px/s）
    launchSpeed *= Math.max(0, 1 - decay*dt);

    // スクロール量
    const dy = Math.max(launchSpeed, minSpeed) * dt; // 下限以下なら下限で伸びるが、すぐ記録へ

    // 背景＆距離更新
    bgScroll += dy;
    totalDist += dy / (100*DPR);
    $distText.textContent = `${totalDist.toFixed(1)} m`;

    // 実質的に停止（minSpeed未満）を検知
    if (launchSpeed < minSpeed){
      stopAndRecord();
    }
  }

  // 角丸矩形
  function roundRect(c, x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
  }

  // 開始
  let started = false;
  function kickstart(){ if (started) return; started = true; beginIntro(); }
  document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState==='visible') fit(); });
  window.addEventListener('load', kickstart);
})();
</script>
</body>
</html>
