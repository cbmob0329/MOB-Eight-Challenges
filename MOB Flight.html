<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>MOB æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ï¼ˆ32pxãƒ»åˆ†æ•£AIãƒ»å¿«é©æ“ä½œï¼‰</title>
<style>
  :root{
    --bg:#05060a; --fg:#e8f0ff; --hud:#0e1220cc; --accent:#5ad1ff; --warn:#ff6b6b;
  }
  html,body{margin:0;height:100%;background:#000;color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif;}
  #wrap{position:fixed; inset:0; display:flex; background:#000;}
  #cv{flex:1; display:block; width:100%; height:100%; touch-action:none; background:#000;}

  /* HUDï¼ˆå°ã•ã‚ï¼‰ */
  .hud{position:fixed; left:0; right:0; top:0; padding:calc(env(safe-area-inset-top) + 4px) 6px 4px 6px; display:flex; gap:6px; align-items:center; justify-content:space-between; pointer-events:none}
  .pill{background:var(--hud); backdrop-filter: blur(6px); padding:4px 8px; border-radius:999px; font-size:11px; line-height:1; display:flex; align-items:center; gap:8px; box-shadow:0 3px 12px #0008}
  .bar{height:5px; width:110px; background:#233; border-radius:6px; overflow:hidden}
  .fill{height:100%; background:linear-gradient(90deg,#42ffd9,#36a3ff,#7d5bff); width:0%}
  .ammo{min-width:60px; text-align:right}
  .legend{opacity:.8}

  /* Controlsï¼ˆå°ã•ã‚ï¼‰ */
  .ctrl{position:fixed; inset:auto; pointer-events:none}
  #stick{left:10px; bottom:calc(env(safe-area-inset-bottom) + 8px); width:120px; height:120px;}
  #fire{right:10px; bottom:calc(env(safe-area-inset-bottom) + 14px); width:90px; height:90px;}
  .joypad{pointer-events:auto; touch-action:none; position:absolute; inset:0; border-radius:999px; background:radial-gradient(90px 90px at 50% 50%, #1b2334cc, #0b0f1acc); box-shadow:0 6px 20px #000a, inset 0 0 0 2px #2d395d;}
  .knob{position:absolute; left:50%; top:50%; width:48px; height:48px; transform:translate(-50%,-50%); border-radius:999px; background:linear-gradient(#1b9cff,#1a6dd8); box-shadow:0 5px 14px #000a, inset 0 0 10px #fff4}
  .firebtn{pointer-events:auto; touch-action:none; position:absolute; inset:0; border-radius:999px; background:radial-gradient(70px 70px at 50% 50%, #2a1b1bcc, #140909cc); box-shadow:0 6px 20px #000a, inset 0 0 0 2px #5b2d2d;}
  .firebtn::after{content:"FIRE"; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); font-weight:700; letter-spacing:.06em; font-size:12px;}
  .tip{position:fixed; left:50%; bottom:calc(env(safe-area-inset-bottom) + 6px); transform:translateX(-50%); font-size:10px; opacity:.7}

  @media (max-height:480px){ .tip{display:none;} }
</style>
</head>
<body>
<div id="wrap"><canvas id="cv" width="960" height="540"></canvas></div>

<!-- HUD -->
<div class="hud">
  <div class="pill">
    <span>â© Distance</span>
    <div class="bar"><div id="distFill" class="fill" style="width:0%"></div></div>
    <span id="distTxt">0 m</span>
  </div>
  <div class="pill">
    <span>ğŸ’° <b id="score">0</b></span>
    <span class="legend">| Ammo</span>
    <span class="ammo" id="ammo">10 / 10</span>
    <span class="legend" id="reload" style="color:var(--warn)"></span>
  </div>
  <div class="pill"><span class="legend">Tapï¼šæ“ä½œåˆ‡æ›¿ / FIREé•·æŠ¼ã—ï¼šå°„æ’ƒ</span></div>
</div>

<!-- Controls -->
<div id="stick" class="ctrl">
  <div id="stickPad" class="joypad"></div>
  <div id="stickKnob" class="knob"></div>
</div>
<div id="fire" class="ctrl"><div id="fireBtn" class="firebtn"></div></div>
<div class="tip">4æ©Ÿç·¨éšŠã€‚å‘³æ–¹ã¯å„è‡ªã®æ•µã‚’æ‹…å½“ã—åˆ†æ•£è¡Œå‹•ã€‚ã‚¿ãƒƒãƒ—ã§æ“ç¸¦æ©Ÿåˆ‡æ›¿ã€‚</div>

<script>
(()=>{
/* ================= Canvas & DPR ================= */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
let W=0,H=0, DPR=1;
function fit(){
  DPR = Math.min(2, window.devicePixelRatio||1);
  W = cv.clientWidth * DPR; H = cv.clientHeight * DPR;
  cv.width = W; cv.height = H;
}
addEventListener('resize', fit, {passive:true}); fit();

/* ================= Utils ================= */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rand=(a,b)=>a+Math.random()*(b-a);

/* ================= Assets ================= */
const IMG = {
  red:'1REDW.png', blue:'1BLUEW.png', orange:'1ORANGEW.png', ver:'1VERW.png',
  enemy:'karasu.png', coin:'coin.png'
};
const images = {};
function load(name, src){ return new Promise(res=>{ const im=new Image(); im.src=src; im.onload=()=>res(images[name]=im); im.onerror=()=>res(images[name]=im); }); }
async function loadAll(){ await Promise.all(Object.entries(IMG).map(([k,v])=>load(k,v))); }
const HUD={ score:qs('#score'), distTxt:qs('#distTxt'), distFill:qs('#distFill'), ammo:qs('#ammo'), reload:qs('#reload') };
function qs(s){return document.querySelector(s)}

/* ================= Inputï¼ˆé«˜å¿œç­”ï¼‰ ================= */
const stickPad = document.getElementById('stickPad');
const stickKnob = document.getElementById('stickKnob');
const fireBtn = document.getElementById('fireBtn');
let stick = {active:false, cx:0, cy:0, dx:0, dy:0, max:44};
let firing=false;

function padCenter(el){ const r=el.getBoundingClientRect(); return {x:r.left+r.width/2, y:r.top+r.height/2}; }
function onStickStart(e){ e.preventDefault(); const c=padCenter(stickPad); stick.active=true; stick.cx=c.x; stick.cy=c.y; onStickMove(e); }
function onStickMove(e){
  if(!stick.active) return;
  e.preventDefault();
  const p=('touches'in e? e.touches[0] : e);
  const dx=p.clientX-stick.cx, dy=p.clientY-stick.cy, m=Math.hypot(dx,dy), lim=stick.max;
  const nx = m>lim? dx/m*lim : dx; const ny = m>lim? dy/m*lim : dy;
  stick.dx = nx/lim; stick.dy = ny/lim;
  stickKnob.style.transform = `translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;
}
function onStickEnd(e){ e.preventDefault(); stick.active=false; stick.dx=0; stick.dy=0; stickKnob.style.transform='translate(-50%,-50%)'; }
stickPad.addEventListener('touchstart', onStickStart, {passive:false});
stickPad.addEventListener('touchmove', onStickMove, {passive:false});
stickPad.addEventListener('touchend', onStickEnd, {passive:false});
stickPad.addEventListener('mousedown', onStickStart);
addEventListener('mousemove', e=>stick.active&&onStickMove(e));
addEventListener('mouseup', onStickEnd);

function fireStart(e){ e.preventDefault(); firing=true; }
function fireEnd(e){ e.preventDefault(); firing=false; }
fireBtn.addEventListener('touchstart', fireStart, {passive:false});
fireBtn.addEventListener('touchend', fireEnd, {passive:false});
fireBtn.addEventListener('mousedown', fireStart);
addEventListener('mouseup', fireEnd);

/* ================= World ================= */
const world={ speed: 125, t:0, distance:0, score:0 };
const walls={ top: 20, bottom: ()=>H-20 };

/* ================= Tuningï¼ˆå¿«é©æ“ä½œï¼†åˆ†æ•£AIï¼‰ ================= */
const TARGET_SPRITE = 32;            // è¡¨ç¤ºåŸºæº–
const PLAYER_SPEED  = 290;           // æ“ä½œæ©Ÿã®æœ€é«˜é€Ÿåº¦ï¼ˆé«˜å¿œç­”ï¼‰
const ALLY_SPEED    = 260;           // å‘³æ–¹å·¡èˆªé€Ÿåº¦
const BULLET_SPEED  = 380;           // è‡ªå¼¾
const EBULLET_SPEED = 120;           // æ•µå¼¾ï¼ˆé…ã‚ï¼‰
const BULLET_R = 3;                  // å¼¾åŠå¾„
const COIN_R   = 8;
const HP_MAX   = 10;

// åˆ†æ•£AIï¼šæ‹…å½“ãƒ¬ãƒ¼ãƒ³(Yç›®æ¨™)ãƒ»åˆ†é›¢åŠ›ãƒ»æˆ¦é—˜è·é›¢
const LANE_OFFS = [-80, -26, +26, +80];     // 4æ©Ÿã®ç¸¦ãƒ¬ãƒ¼ãƒ³
const SEP_RADIUS = 44;                       // åˆ†é›¢è·é›¢
const SEP_FORCE  = 240;                      // åˆ†é›¢ã®å¼·ã•
const ENGAGE_DIST_X = 160;                   // æ•µã¨ä¿ã¤Xè·é›¢
const ENGAGE_DIST_Y = 20;                    // æ•µã¨ä¿ã¤Yè·é›¢
const FIRE_RANGE   = 260;                    // å‘³æ–¹AIã®å°„ç¨‹

/* ================= Entities ================= */
const bullets=[], ebullets=[], enemies=[], coins=[];
function spawnBullet(x,y){ bullets.push({x,y,vx:BULLET_SPEED,vy:0,r:BULLET_R*DPR,dmg:1}); }
function spawnEBullet(x,y,tx,ty){
  const a=Math.atan2(ty-y, tx-x);
  ebullets.push({x,y,vx:Math.cos(a)*EBULLET_SPEED,vy:Math.sin(a)*EBULLET_SPEED,r:BULLET_R*DPR,dmg:1});
}

function makeAlly(imgKey, idx){
  const im=images[imgKey];
  const scale = (TARGET_SPRITE*DPR) / Math.max(1, im.width);
  return {
    sprite:im, scale,
    x: 120*DPR + idx*22*DPR,
    y: clamp(H*0.5 + LANE_OFFS[idx%LANE_OFFS.length]*DPR, walls.top+18*DPR, walls.bottom()-18*DPR),
    vx:0, vy:0,
    hpMax:HP_MAX, hp:HP_MAX,
    alive:true, dying:false, rot:0, dieT:0,
    fire:{ammo:10, ammoMax:10, cd:0, rate:0.09, reload:0, reloadTime:0.5},
    lane: LANE_OFFS[idx%LANE_OFFS.length],
    targetId: -1   // æ‹…å½“æ•µ index
  };
}
let team=[], controlIndex=0, controlTarget=null;
function initTeam(){
  team=[ makeAlly('red',0), makeAlly('blue',1), makeAlly('orange',2), makeAlly('ver',3) ];
  controlIndex=0; controlTarget=team[0]; // åˆæœŸãƒ¬ãƒƒãƒ‰æ“ä½œ
}

/* ================= Spawners ================= */
function spawnEnemy(){
  const im=images.enemy;
  const scale=(TARGET_SPRITE*DPR)/Math.max(1, im.width);
  const y = rand(walls.top+24*DPR, walls.bottom()-24*DPR);
  const x = W + rand(24*DPR, 180*DPR);
  enemies.push({sprite:im, scale, x,y, hp:3, alive:true, fireCd: rand(0.9,1.7)});
}
function spawnCoin(){
  const im=images.coin;
  const scale=(20*DPR)/Math.max(1, im.width);
  const y = rand(walls.top+22*DPR, walls.bottom()-22*DPR);
  const x = W + rand(10*DPR, 120*DPR);
  coins.push({sprite:im,scale,x,y,vx:-world.speed*0.9, taken:false});
}

/* ================= Helpers ================= */
function hitCircleRect(cx,cy,cr, rx,ry,rw,rh){
  const nx = Math.max(rx, Math.min(cx, rx+rw));
  const ny = Math.max(ry, Math.min(cy, ry+rh));
  const dx=cx-nx, dy=cy-ny;
  return dx*dx+dy*dy <= cr*cr;
}
function prune(arr, keep){ let w=0; for(let i=0;i<arr.length;i++) if(keep(arr[i])) arr[w++]=arr[i]; arr.length=w; }

/* ====== åˆ†æ•£AIï¼šæ‹…å½“æ•µã®å‰²å½“ ====== */
function assignTargets(){
  if(enemies.length===0){ for(const a of team) a.targetId=-1; return; }
  // å„å‘³æ–¹ã«æœ€å¯„ã‚Šæ•µã‚’å‰²å½“ï¼ˆå˜ç´”è²ªæ¬²ï¼‰
  for(const a of team){
    if(!a.alive && !a.dying) continue;
    let best=-1, bd=1e9;
    for(let i=0;i<enemies.length;i++){
      const e=enemies[i]; if(!e.alive) continue;
      const d=Math.hypot(e.x-a.x, e.y-a.y);
      if(d<bd){ bd=d; best=i; }
    }
    a.targetId = best;
  }
}

/* ================= Update ================= */
let last=0;
function update(dt){
  world.t+=dt;
  world.distance += (world.speed*dt)/70;

  // å‡ºç¾å¯†åº¦ï¼ˆè·é›¢ã§å¢—åŠ ï¼‰
  const diff = Math.min(1, world.distance/1200);
  if(Math.random() < (0.50+diff*1.1)*dt) spawnEnemy();
  if(Math.random() < (0.65+diff*0.9)*dt) spawnCoin();

  // æ•µAIï¼ˆå³å¯„ã‚Šãƒ»ä¸€å®šé€Ÿåº¦ã§å·¦ã¸æµã‚Œã‚‹ã ã‘ã«ç°¡ç•¥åŒ–ï¼‰
  for(const e of enemies){
    if(!e.alive) continue;
    e.x += -world.speed*dt; // å³å¯„ã‚Šç¶­æŒã¯ã—ãªã„ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å´ã®é€²è¡Œã§å¸¸ã«å³ã«å­˜åœ¨
    // ç¸¦ã«ã‚†ã‚‰ã
    e.y += Math.sin((world.t*2.2)+(e.x*0.005))*22*dt*DPR;
    e.y = clamp(e.y, walls.top+22*DPR, walls.bottom()-22*DPR);
    e.fireCd -= dt;
    if(e.fireCd<=0){
      // æœ€ã‚‚è¿‘ã„ç·¨éšŠæ©Ÿã«å‘ã‘ã¦ä½é€Ÿå¼¾
      let tar=team[0]; let bd=1e9;
      for(const a of team){ if(!a.alive || a.dying) continue; const d=Math.hypot(a.x-e.x, a.y-e.y); if(d<bd){bd=d; tar=a;} }
      if(tar) spawnEBullet(e.x-8*DPR, e.y, tar.x, tar.y);
      e.fireCd = rand(1.0,1.8) - diff*0.3;
    }
    if(e.x<-80*DPR) e.alive=false;
  }

  // å‘³æ–¹ã®æ‹…å½“æ›´æ–°ï¼ˆæ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã§OKï¼šè»½é‡ï¼‰
  assignTargets();

  // Teamï¼ˆå¿«é©æ“ä½œ & åˆ†æ•£AIï¼‰
  for(let i=0;i<team.length;i++){
    const a=team[i];
    if(!a.alive && !a.dying) continue;
    if(a.dying){
      a.dieT+=dt; a.rot+=dt*6; a.y += 100*dt;
      continue;
    }

    if(i===controlIndex){
      // ç›´æ¥é€Ÿåº¦ï¼šã‚‚ãŸã¤ãç„¡ã—
      a.vx = stick.dx * PLAYER_SPEED*DPR;
      a.vy = stick.dy * PLAYER_SPEED*DPR;
    }else{
      // ===== åˆ†æ•£AI =====
      // 1) åŸºæœ¬ç›®çš„åœ°ï¼šæ‹…å½“æ•µã®å°‘ã—å·¦å¾Œæ–¹ï¼ˆENGAGEè·é›¢ã‚’ä¿ã¤ï¼‰
      let tx = a.x + 60*DPR; // ãƒ‡ãƒ•ã‚©ã¯å‰é€²
      let ty = H*0.5 + a.lane*DPR; // ãƒ¬ãƒ¼ãƒ³ã‚’ãƒ™ãƒ¼ã‚¹
      const tid=a.targetId;
      if(tid>=0 && enemies[tid] && enemies[tid].alive){
        const e=enemies[tid];
        tx = e.x - ENGAGE_DIST_X*DPR;               // æ•µã®å·¦å´ã¸å›ã‚Šè¾¼ã¿
        ty = clamp(e.y + ((i%2===0)?-ENGAGE_DIST_Y:ENGAGE_DIST_Y)*DPR, walls.top+18*DPR, walls.bottom()-18*DPR);
      }else{
        // æ•µãŒã„ãªã„æ™‚ã¯å„ãƒ¬ãƒ¼ãƒ³å·¡å›ï¼ˆå‰æ–¹ã¸ï¼‰
        tx = Math.max(a.x, controlTarget.x + (60 + i*24)*DPR);
      }

      // 2) åˆ†é›¢ï¼ˆSeparationï¼‰ï¼šè¿‘ã™ãã‚‹å‘³æ–¹ã‹ã‚‰é›¢ã‚Œã‚‹åŠ›
      let sfx=0, sfy=0;
      for(let j=0;j<team.length;j++){
        if(j===i) continue;
        const b=team[j]; if(!b.alive && !b.dying) continue;
        const dx=a.x-b.x, dy=a.y-b.y, d=Math.hypot(dx,dy);
        if(d>0 && d<SEP_RADIUS*DPR){
          const w = (SEP_RADIUS*DPR - d) / (SEP_RADIUS*DPR);
          sfx += (dx/d) * SEP_FORCE * w;
          sfy += (dy/d) * SEP_FORCE * w;
        }
      }

      // 3) ç›®æ¨™é€Ÿåº¦
      const dx = tx - a.x, dy = ty - a.y, dm = Math.hypot(dx,dy) || 1;
      const vx_des = dx/dm * ALLY_SPEED*DPR + sfx;
      const vy_des = dy/dm * ALLY_SPEED*DPR + sfy;

      // ãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆå¯„ã‚Šã®è¿½å¾“ï¼ˆæ…£æ€§å¼±ï¼‰ï¼šè£œé–“ä¿‚æ•°ã‚’å¼·ã‚ã«
      const k = 0.6; // 0ã€œ1ï¼ˆæ•°å€¤â†‘ã§ã‚­ãƒ“ã‚­ãƒ“ï¼‰
      a.vx = a.vx*(1-k) + vx_des*k;
      a.vy = a.vy*(1-k) + vy_des*k;
    }

    // ä½ç½®æ›´æ–°ï¼†å£åˆ¶é™
    a.x = clamp(a.x + a.vx*dt, 24*DPR, W*0.75);
    a.y = clamp(a.y + a.vy*dt, walls.top+16*DPR, walls.bottom()-16*DPR);

    // å°„æ’ƒï¼šæ“ç¸¦æ©Ÿã¯ãƒœã‚¿ãƒ³ã€å‘³æ–¹ã¯æ‹…å½“æ•µãŒå‰æ–¹ã‹å°„ç¨‹å†…ãªã‚‰ç™ºç ²
    a.fire.cd -= dt;
    if(a.fire.reload>0){
      a.fire.reload -= dt;
      if(a.fire.reload<=0) a.fire.ammo=a.fire.ammoMax;
    }else{
      let should=false;
      if(i===controlIndex) should = firing;
      else{
        const tid=a.targetId;
        if(tid>=0 && enemies[tid] && enemies[tid].alive){
          const e=enemies[tid];
          const inFront = e.x > a.x;
          const inRange = Math.abs(e.x - a.x) < FIRE_RANGE*DPR && Math.abs(e.y - a.y) < 60*DPR;
          should = inFront && inRange;
        }
      }
      if(should && a.fire.cd<=0 && a.fire.ammo>0){
        a.fire.cd = a.fire.rate; a.fire.ammo--;
        spawnBullet(a.x + 18*DPR, a.y);
        if(a.fire.ammo===0) a.fire.reload = a.fire.reloadTime;
      }
    }
  }

  // Bullets
  for(const b of bullets){ b.x += (b.vx - world.speed*0.15)*dt; }
  for(const b of ebullets){ b.x += (b.vx - world.speed*0.05)*dt; b.y += b.vy*dt; }

  // Coins
  for(const c of coins){ c.x += c.vx*dt; if(c.x<-24*DPR) c.taken=true; }

  // è¡çªï¼šå‘³æ–¹å¼¾â†’æ•µ
  for(const b of bullets){
    for(const e of enemies){
      if(!e.alive) continue;
      const w=e.sprite.width*e.scale, h=e.sprite.height*e.scale;
      const rx=e.x-w/2, ry=e.y-h/2;
      if(hitCircleRect(b.x,b.y,b.r, rx,ry,w,h)){
        e.hp--; b.x=-1e9;
        if(e.hp<=0){ e.alive=false; world.score+=20; if(Math.random()<0.6) spawnCoin(); } else { world.score+=5; }
      }
    }
  }
  // è¡çªï¼šæ•µå¼¾â†’ç·¨éšŠ
  for(const eb of ebullets){
    for(const a of team){
      if(!a.alive || a.dying) continue;
      const w=a.sprite.width*a.scale, h=a.sprite.height*a.scale;
      const rx=a.x-w/2, ry=a.y-h/2;
      if(hitCircleRect(eb.x,eb.y,eb.r, rx,ry,w,h)){
        a.hp--; eb.x=-1e9;
        if(a.hp<=0){ a.dying=true; a.alive=false; a.dieT=0; a.rot=0; }
      }
    }
  }
  // ã‚³ã‚¤ãƒ³å–å¾—
  for(const c of coins){
    if(c.taken) continue;
    for(const a of team){
      if(!a.alive) continue;
      const w=a.sprite.width*a.scale, h=a.sprite.height*a.scale;
      if(hitCircleRect(c.x,c.y, COIN_R*DPR, a.x-w/2, a.y-h/2, w, h)){ c.taken=true; world.score+=10; break; }
    }
  }

  // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  prune(bullets, b=> b.x>-40*DPR && b.x<W+40*DPR);
  prune(ebullets, b=> b.x>-60*DPR && b.x<W+60*DPR && b.y>-60*DPR && b.y<H+60*DPR);
  prune(enemies, e=> e.alive || e.x>-120*DPR);
  prune(coins, c=> !c.taken);

  // HUD
  const ctrl=team[controlIndex];
  if(ctrl){
    HUD.ammo.textContent = `${ctrl.fire.ammo} / ${ctrl.fire.ammoMax}`;
    HUD.reload.textContent = ctrl.fire.reload>0 ? `RELOAD ${ctrl.fire.reload.toFixed(2)}s` : '';
  }
  HUD.score.textContent = world.score|0;
  HUD.distTxt.textContent = `${(world.distance|0)} m`;
  HUD.distFill.style.width = `${Math.min(100, (world.distance%1000)/10)}%`;
}

/* ================= Render ================= */
function render(){
  ctx.clearRect(0,0,W,H);
  // èƒŒæ™¯
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#0a1126'); g.addColorStop(1,'#050814');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

  // ãƒ‘ãƒ©ãƒ©ãƒƒã‚¯ã‚¹ç´°ãƒ©ã‚¤ãƒ³
  const t = world.t, sp=world.speed*0.45;
  ctx.globalAlpha=0.22; ctx.fillStyle='#0ff3';
  for(let y=walls.top; y<H-walls.top; y+=32*DPR){
    const x = (W - ((t*sp + y*18)%(W+140))) - 140;
    ctx.fillRect(x,y,120,1);
  }
  ctx.globalAlpha=1;

  // å£
  ctx.fillStyle='#1a253a';
  ctx.fillRect(0,0,W,walls.top);
  ctx.fillRect(0,walls.bottom(),W,H-walls.bottom());
  ctx.strokeStyle='#2e3e63'; ctx.lineWidth=2*DPR;
  ctx.beginPath(); ctx.moveTo(0, walls.top); ctx.lineTo(W, walls.top); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, walls.bottom()); ctx.lineTo(W, walls.bottom()); ctx.stroke();

  // ã‚³ã‚¤ãƒ³
  for(const c of coins){
    const w=c.sprite.width*c.scale, h=c.sprite.height*c.scale;
    ctx.save(); ctx.translate(c.x,c.y);
    ctx.rotate(Math.sin(t*5 + c.x*0.02)*0.12);
    ctx.drawImage(c.sprite,-w/2,-h/2,w,h);
    ctx.restore();
  }

  // æ•µ
  for(const e of enemies){
    if(!e.alive) continue;
    const w=e.sprite.width*e.scale, h=e.sprite.height*e.scale;
    ctx.drawImage(e.sprite, e.x-w/2, e.y-h/2, w, h);
  }

  // å¼¾
  ctx.fillStyle='#aff';
  for(const b of bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
  ctx.fillStyle='#f88';
  for(const b of ebullets){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }

  // ç·¨éšŠ
  for(let i=0;i<team.length;i++){
    const a=team[i];
    const w=a.sprite.width*a.scale, h=a.sprite.height*a.scale;
    ctx.save(); ctx.translate(a.x,a.y);
    if(a.dying){
      const alpha=Math.max(0,1 - a.dieT/0.8);
      ctx.globalAlpha=alpha; ctx.rotate(a.rot);
      ctx.drawImage(a.sprite,-w/2,-h/2,w,h); ctx.restore(); continue;
    }
    ctx.drawImage(a.sprite,-w/2,-h/2,w,h);
    // HPãƒãƒ¼ï¼ˆå°å‹ï¼‰
    const bw=26*DPR, bh=4*DPR, bx=-bw/2, by= -h/2 - 8*DPR;
    ctx.fillStyle='#000a'; ctx.fillRect(bx-1,by-1,bw+2,bh+2);
    ctx.fillStyle='#223d'; ctx.fillRect(bx,by,bw,bh);
    ctx.fillStyle = (i===controlIndex?'#6ff':'#6f6');
    ctx.fillRect(bx,by,(a.hp/a.hpMax)*bw,bh);
    // é¸æŠãƒªãƒ³ã‚°
    if(i===controlIndex){
      ctx.strokeStyle='#6ff'; ctx.lineWidth=1.5*DPR;
      ctx.beginPath(); ctx.arc(0,0, Math.max(w,h)*0.55, 0, Math.PI*2); ctx.stroke();
    }
    ctx.restore();
  }

  // èµ°æŸ»ç·š
  ctx.globalAlpha=0.06; ctx.fillStyle='#fff';
  for(let y=0;y<H;y+=2*DPR) ctx.fillRect(0,y,W,1*DPR);
  ctx.globalAlpha=1;
}

/* ================= Tapï¼šæ“ç¸¦æ©Ÿåˆ‡æ›¿ ================= */
cv.addEventListener('click', (e)=>{
  const r=cv.getBoundingClientRect(), x=(e.clientX-r.left)*DPR, y=(e.clientY-r.top)*DPR;
  let best=-1, bd=1e9;
  for(let i=0;i<team.length;i++){
    const a=team[i]; if(!a.alive && !a.dying) continue;
    const d=Math.hypot(a.x-x,a.y-y); if(d<bd){bd=d; best=i;}
  }
  if(best>=0 && bd<40*DPR){ controlIndex=best; controlTarget=team[controlIndex]; }
  else{
    for(let k=1;k<=team.length;k++){
      const j=(controlIndex+k)%team.length;
      if(team[j].alive || team[j].dying){ controlIndex=j; controlTarget=team[j]; break; }
    }
  }
});

/* ================= Loop ================= */
function loop(ts){
  if(!last) last=ts;
  const dt=Math.min(0.033,(ts-last)/1000); last=ts;
  update(dt); render();
  requestAnimationFrame(loop);
}

/* ================= Start ================= */
loadAll().then(()=>{ initTeam(); requestAnimationFrame(loop); });

/* ================= Keyboardï¼ˆPCãƒ†ã‚¹ãƒˆï¼‰ ================= */
const keys={};
addEventListener('keydown',e=>{ keys[e.key]=true; if(e.key===' ') firing=true; });
addEventListener('keyup',e=>{ keys[e.key]=false; if(e.key===' ') firing=false; });
setInterval(()=>{
  stick.dy = (keys['ArrowUp']?-1:0) + (keys['ArrowDown']?1:0);
  stick.dx = (keys['ArrowLeft']?-1:0) + (keys['ArrowRight']?1:0);
}, 16);

})();
</script>
</body>
</html>
