<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no">
<title>MOB Hockey Race</title>
<style>
  :root{ --fg:#e9eef7; --dim:#9aa3b2; }
  html,body{margin:0;height:100%;background:#000;color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif}
  #cv{width:100%;height:100%;display:block;touch-action:none;background:#000}
  #overlay{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;background:rgba(0,0,0,.72);z-index:20}
  #overlay h1{margin:0;font-size:2rem}
  .btn{background:#1b2235;color:#fff;border:1px solid #2a3552;padding:12px 18px;border-radius:12px;min-width:120px;font-size:1.05rem}
  #hud{position:fixed;left:8px;top:8px;background:rgba(0,0,0,.4);border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:6px 10px;font-size:.9rem;z-index:15}
  #touchHint{position:fixed;left:0;right:0;bottom:0;height:28%;display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;padding:10px;opacity:.35;pointer-events:none;z-index:10}
  .zone{border:1px dashed rgba(255,255,255,.35);border-radius:12px;display:flex;align-items:center;justify-content:center;font-weight:700}
  #result{position:fixed;inset:0;display:none;flex-direction:column;align-items:center;justify-content:center;gap:12px;background:rgba(0,0,0,.75);z-index:25}
  #result table{border-collapse:collapse}
  #result td{padding:6px 12px;border-bottom:1px solid rgba(255,255,255,.1)}
  #result tr:last-child td{border-bottom:none}
  #loading{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;color:#fff;z-index:30}
</style>
</head>
<body>
<canvas id="cv"></canvas>

<div id="hud">RACE: <span id="raceNum">1</span> / 3</div>

<div id="overlay">
  <h1>ゲーム開始しますか？</h1>
  <div>
    <button class="btn" id="okBtn">はい</button>
    <button class="btn" id="noBtn">いいえ</button>
  </div>
  <div style="font-size:.95rem;color:#9fb3d9">操作は ← / → / ↑（中央タップで↑）<br>プレイヤー：赤。他はCPU。</div>
</div>

<div id="touchHint"><div class="zone">←</div><div class="zone">↑</div><div class="zone">→</div></div>

<div id="result">
  <h2 id="resultTitle">FINISH!</h2>
  <div class="tbl"><table id="resultTable"></table></div>
  <div>
    <button class="btn" id="nextBtn">次のレース</button>
    <button class="btn" id="restartBtn" style="display:none">最初から</button>
  </div>
</div>

<div id="loading">Loading...</div>

<script>
(()=>{
// ===== Canvas / DPR =====
const cv = document.getElementById('cv');
const cx = cv.getContext('2d',{alpha:false});
let DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio||1));
function resize(){ cv.width = Math.floor(innerWidth*DPR); cv.height = Math.floor(innerHeight*DPR); cv.style.width=innerWidth+'px'; cv.style.height=innerHeight+'px'; }
addEventListener('resize',()=>{DPR=Math.max(1,Math.min(2.5,devicePixelRatio||1)); resize(); buildIfReady();});
resize();

// ===== Assets =====
const files = {
  red:'red.png', blue:'blue.png', yellow:'yellow.png', black:'black.png',
  pink:'pink.png', orange:'orange.png', green:'green.png', mura:'mura.png',
  contena:'contena.png', gomi:'gomi.png', hoke:'hoke.png'
};
const img = {};
function loadImage(src){return new Promise((res,rej)=>{const i=new Image();i.onload=()=>res(i);i.onerror=rej;i.src=src;});}
async function loadAll(){for(const k in files){img[k]=await loadImage(files[k]);}}

// ===== Track & Wall Mask (from hoke.png) =====
let WORLD_W=cv.width, WORLD_H=cv.height*2;
const maskC=document.createElement('canvas'), maskX=maskC.getContext('2d');
let wallData=null, wallW=0, wallH=0;
const WALL_THRESHOLD=85; // 暗い部分を壁として採用（細線OK）

function buildWallMask(){
  const ratio = img.hoke.height / img.hoke.width;
  WORLD_W = cv.width;
  WORLD_H = Math.max(cv.height*1.8, Math.floor(WORLD_W*ratio));
  maskC.width=WORLD_W; maskC.height=WORLD_H;
  maskX.clearRect(0,0,WORLD_W,WORLD_H);
  maskX.drawImage(img.hoke,0,0,WORLD_W,WORLD_H);
  const d = maskX.getImageData(0,0,WORLD_W,WORLD_H);
  wallData=d.data; wallW=WORLD_W; wallH=WORLD_H;
}

function isWall(px,py){
  if(px<0||py<0||px>=wallW||py>=wallH) return true;
  const idx=((py|0)*wallW+(px|0))*4;
  const r=wallData[idx],g=wallData[idx+1],b=wallData[idx+2],a=wallData[idx+3];
  if(a<12) return false;
  const bright=r*0.299+g*0.587+b*0.114;
  return bright<WALL_THRESHOLD;
}

function rectTouchesWall(x,y,w,h,step=5){
  for(let sx=x; sx<=x+w; sx+=step){ if(isWall(sx,y) || isWall(sx,y+h)) return true; }
  for(let sy=y; sy<=y+h; sy+=step){ if(isWall(x,sy) || isWall(x+w,sy)) return true; }
  // 中も軽くサンプル（極細壁の取りこぼし対策）
  for(let sx=x+step; sx<x+w; sx+=step){ for(let sy=y+step; sy<y+h; sy+=step){ if(isWall(sx,sy)) return true; } }
  return false;
}

// ===== Entities =====
const COLORS=['red','blue','yellow','black','pink','orange','green','mura'];
const COLOR_JP={red:'赤',blue:'青',yellow:'黄',black:'黒',pink:'ピンク',orange:'オレンジ',green:'緑',mura:'紫'};
const BALL_SZ=34, R=BALL_SZ/2; // 小さめ
const CONT_W=92, CONT_H=78;
const GOMI_W=68, GOMI_H=82;

let balls=[], obstacles=[], finishOrder=[];
let raceNo=1, fastMode=false, playerFinished=false;
const totalPts={}; COLORS.forEach(c=>totalPts[c]=0);
let camY=0;

function makeBall(color,x,y){
  return {color,x,y,w:BALL_SZ,h:BALL_SZ,vx:0,vy:-0.6,spd:0.9,finished:false,tFinish:0};
}

// ===== Inputs (← → ↑ のみ) =====
const keys=Object.create(null);
addEventListener('keydown',e=>{if(['ArrowLeft','ArrowRight','ArrowUp'].includes(e.key)) keys[e.key]=true;});
addEventListener('keyup',e=>{if(['ArrowLeft','ArrowRight','ArrowUp'].includes(e.key)) keys[e.key]=false;});
let tLeft=false,tRight=false,tUp=false;
function touchHandler(e,down){
  for(const t of e.changedTouches){
    const x=t.clientX,y=t.clientY;
    if(y>=innerHeight*0.72){
      if(x<innerWidth/3){tLeft=down;}
      else if(x>innerWidth*2/3){tRight=down;}
      else {tUp=down;}
    }
  }
}
cv.addEventListener('touchstart',e=>touchHandler(e,true),{passive:true});
cv.addEventListener('touchend',e=>touchHandler(e,false),{passive:true});
cv.addEventListener('touchcancel',()=>{tLeft=tRight=tUp=false;},{passive:true});

// ===== Geometry helpers =====
function clamp(v,a,b){return v<a?a:(v>b?b:v);}
function aabbOverlap(ax,ay,aw,ah,bx,by,bw,bh){return !(ax+aw<=bx || bx+bw<=ax || ay+ah<=by || by+bh<=ay);}

// 円と矩形の当たり（反射）
function circleRectBounce(b,o){
  // 最近点
  const cx=b.x+R, cy=b.y+R;
  const nx=clamp(cx,o.x,o.x+o.w);
  const ny=clamp(cy,o.y,o.y+o.h);
  const dx=cx-nx, dy=cy-ny;
  const dist2=dx*dx+dy*dy;
  if(dist2>R*R) return false;
  const d=Math.sqrt(Math.max(0.0001,dist2));
  const nxn=dx/d, nyn=dy/d; // 法線
  // 押し出し
  const overlap=R-d+0.5;
  b.x += nxn*overlap;
  b.y += nyn*overlap;
  // 速度反射（法線反転）
  const vn=b.vx*nxn + b.vy*nyn;
  b.vx -= 1.8*vn*nxn;
  b.vy -= 1.8*vn*nyn;
  b.vx*=0.9; b.vy*=0.9;
  return true;
}

// 円と円の弾性反発
function circleCircleBounce(a,b){
  const ax=a.x+R, ay=a.y+R, bx=b.x+R, by=b.y+R;
  let dx=bx-ax, dy=by-ay;
  const dist2=dx*dx+dy*dy, minD=R*2*0.95;
  if(dist2>minD*minD) return false;
  const d=Math.sqrt(Math.max(0.0001,dist2));
  const nx=dx/d, ny=dy/d;
  const overlap=(minD-d)/2;
  a.x -= nx*overlap; a.y -= ny*overlap;
  b.x += nx*overlap; b.y += ny*overlap;
  const avn=a.vx*nx + a.vy*ny;
  const bvn=b.vx*nx + b.vy*ny;
  const diff=bvn-avn;
  a.vx += diff*nx; a.vy += diff*ny;
  b.vx -= diff*nx; b.vy -= diff*ny;
  a.vx*=0.95; a.vy*=0.95; b.vx*=0.95; b.vy*=0.95;
  return true;
}

// 壁反射（マスク）
function bounceWall(b){
  if(!rectTouchesWall(b.x,b.y,b.w,b.h,4)) return false;
  // 少し戻して接触面を推定
  let steps=0;
  while(rectTouchesWall(b.x,b.y,b.w,b.h,3)&&steps<12){ b.x-=b.vx*0.5; b.y-=b.vy*0.5; steps++; }
  // 法線近似：左右/上下へ微小プローブ
  const hitX = rectTouchesWall(b.x+Math.sign(b.vx)*3,b.y,b.w,b.h,4);
  const hitY = rectTouchesWall(b.x,b.y+Math.sign(b.vy)*3,b.w,b.h,4);
  if(!hitX){ b.vx*=-0.8; b.vy*=0.9; }
  else if(!hitY){ b.vy*=-0.8; b.vx*=0.9; }
  else { b.vx*=-0.75; b.vy*=-0.75; }
  return true;
}

// ===== Obstacle placement =====
function clearForRect(x,y,w,h){
  if(rectTouchesWall(x,y,w,h,5)) return false;
  for(const o of obstacles){ if(aabbOverlap(x,y,w,h,o.x,o.y,o.w,o.h)) return false; }
  return true;
}

function placeObstacles(){
  obstacles.length=0;
  const marginX=Math.max(24,WORLD_W*0.05);
  // 通常コンテナ
  const targetCont=6, targetGomi=3;
  function tryPlace(type,w,h,y0,y1){
    for(let t=0;t<200;t++){
      const x = marginX + Math.random()*(WORLD_W - marginX*2 - w);
      const y = y1 + Math.random()*(y0 - y1 - h);
      if(clearForRect(x,y,w,h)){
        obstacles.push({type,x,y,w,h,vx:(type==='gomi'? (Math.random()<.5?-1:1)*Math.random()*1.2 : 0)});
        return true;
      }
    }
    return false;
  }
  for(let i=0;i<targetCont;i++) tryPlace('contena',CONT_W,CONT_H,WORLD_H*0.92,WORLD_H*0.25);
  for(let i=0;i<targetGomi;i++) tryPlace('gomi',GOMI_W,GOMI_H,WORLD_H*0.78,WORLD_H*0.18);

  // 中盤のボトルネック：縦の抜け道を必ず確保
  const botY0=WORLD_H*0.50, botY1=WORLD_H*0.30;
  const gapW=Math.max(90,WORLD_W*0.16);
  const gapX=marginX+60+Math.random()*(WORLD_W - marginX*2 - 120 - gapW);
  const rows=3, cols=4;
  const cellW=(WORLD_W - marginX*2)/cols;
  const cellH=(botY0 - botY1)/rows;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x0=marginX + c*cellW + (cellW-CONT_W)/2;
      const y0=botY0 - (r+1)*cellH + (cellH-CONT_H)/2;
      const cx=x0+CONT_W/2;
      if(cx>gapX && cx<gapX+gapW) continue; // 縦の通路
      let placed=false, x=x0, y=y0;
      for(let t=0;t<60;t++){
        if(clearForRect(x,y,CONT_W,CONT_H)){ obstacles.push({type:'contena',x,y,w:CONT_W,h:CONT_H,vx:0}); placed=true; break; }
        x += (Math.random()-0.5)*16; y += (Math.random()-0.5)*16;
      }
    }
  }
}

// ===== Race init =====
function resetRace(){
  finishOrder.length=0; balls.length=0; fastMode=false; playerFinished=false;
  camY=Math.max(0, WORLD_H - cv.height);

  // 下部に確実に並べる
  const startY=WORLD_H-120-BALL_SZ;
  const laneL=R*2, laneR=WORLD_W-R*2;
  const span=laneR-laneL;
  for(let i=0;i<COLORS.length;i++){
    const x = laneL + (span/(COLORS.length+1))*(i+1) - R;
    const y = startY + (i%2)*6;
    balls.push(makeBall(COLORS[i],x,y));
  }
  placeObstacles();
}

// ===== Game State =====
let inCountdown=false, countdown=3, started=false, lastTs=0;
const overlay=document.getElementById('overlay');
const raceNumEl=document.getElementById('raceNum');
const resultView=document.getElementById('result');
const resultTitle=document.getElementById('resultTitle');
const resultTable=document.getElementById('resultTable');
const nextBtn=document.getElementById('nextBtn');
const restartBtn=document.getElementById('restartBtn');
const loadingEl=document.getElementById('loading');
document.getElementById('okBtn').onclick=()=>{overlay.style.display='none'; startCountdown();};
document.getElementById('noBtn').onclick=()=>{location.reload();};

function startCountdown(){
  inCountdown=true; countdown=3;
  setTimeout(()=>countdown=2,1000);
  setTimeout(()=>countdown=1,2000);
  setTimeout(()=>countdown=0,3000);
  setTimeout(()=>{inCountdown=false; started=true;},3400);
}

// ===== Update / Draw =====
const FINISH_Y=24;

function update(dt){
  if(!started) return;

  // gomi 移動（進行中も重なり/壁を監視）
  for(const o of obstacles){
    if(o.type==='gomi'){
      const mv=(fastMode?3:1);
      let nx=o.x + o.vx*mv;
      // 壁 or 端 or コンテナ衝突で反転
      let reverse = (nx<4 || nx+o.w>WORLD_W-4) || rectTouchesWall(nx,o.y,o.w,o.h,4);
      if(!reverse){
        for(const p of obstacles){
          if(p===o) continue;
          if(aabbOverlap(nx,o.y,o.w,o.h,p.x,p.y,p.w,p.h)){ reverse=true; break; }
        }
      }
      if(reverse){ o.vx*=-1; } else { o.x=nx; }
    }
  }

  // ボール挙動
  for(const b of balls){
    if(b.finished) continue;
    const isPlayer=(b.color==='red');
    const L = keys['ArrowLeft']||tLeft;
    const Rr= keys['ArrowRight']||tRight;
    const U = keys['ArrowUp']||tUp;

    const base = (fastMode?3.2:1.1);
    b.spd += ((isPlayer? base+0.08 : base) - b.spd)*0.01;
    if(isPlayer){
      if(L) b.vx-=0.11;
      if(Rr) b.vx+=0.11;
      if(U) b.spd+=0.02; // 上キーは前進のみ
    }else{
      // 簡易AI：壁を避けつつ蛇行
      b.vx += (Math.random()-0.5)*0.05;
      const aheadY=b.y-20;
      if(rectTouchesWall(b.x-8,aheadY,b.w,b.h,4)) b.vx+=0.12;
      if(rectTouchesWall(b.x+8,aheadY,b.w,b.h,4)) b.vx-=0.12;
    }
    b.vx=clamp(b.vx,-2.4,2.4);
    b.vy = -b.spd*(fastMode?3:1);

    b.x += b.vx; b.y += b.vy;

    // 端ガード
    if(b.x<0){b.x=0; b.vx*=-0.7;}
    if(b.x+b.w>WORLD_W){b.x=WORLD_W-b.w; b.vx*=-0.7;}

    // 壁反射
    bounceWall(b);

    // 障害物反射
    for(const o of obstacles){
      if(aabbOverlap(b.x,b.y,b.w,b.h,o.x,o.y,o.w,o.h)){
        circleRectBounce(b,o);
      }
    }

    // ゴール
    if(b.y<=FINISH_Y){
      b.finished=true; b.tFinish=performance.now(); finishOrder.push(b);
      if(isPlayer && !playerFinished){ playerFinished=true; fastMode=true; }
    }
  }

  // 円同士衝突
  for(let i=0;i<balls.length;i++){
    for(let j=i+1;j<balls.length;j++){
      circleCircleBounce(balls[i],balls[j]);
    }
  }

  // カメラ（プレイヤー追従）
  const player=balls.find(x=>x.color==='red');
  if(player){
    const target=clamp(player.y - cv.height*0.55, 0, Math.max(0,WORLD_H-cv.height));
    camY += (target-camY)*0.1;
  }

  // 終了
  if(finishOrder.length===balls.length){
    started=false;
    setTimeout(()=>showResult(),2000); // FINISH! 2秒
  }
}

function draw(){
  cx.setTransform(1,0,0,1,0,0);
  cx.clearRect(0,0,cv.width,cv.height);
  cx.setTransform(1,0,0,1,0,-camY);

  // 背景
  cx.imageSmoothingEnabled=false;
  cx.drawImage(img.hoke,0,0,WORLD_W,WORLD_H);

  // 障害物
  for(const o of obstacles){ cx.drawImage(img[o.type],o.x,o.y,o.w,o.h); }

  // ボール
  for(const b of balls){ cx.drawImage(img[b.color],b.x,b.y,b.w,b.h); }

  // カウントダウン
  if(inCountdown){
    cx.setTransform(1,0,0,1,0,0);
    cx.fillStyle='rgba(0,0,0,.3)'; cx.fillRect(0,0,cv.width,cv.height);
    cx.fillStyle='#fff'; cx.textAlign='center';
    cx.font='bold '+Math.floor(cv.width*0.22)+'px system-ui';
    cx.fillText(countdown>0?String(countdown):'GO!',cv.width/2,cv.height*0.55);
  }

  // FINISH表示
  if(!started && finishOrder.length===balls.length){
    cx.setTransform(1,0,0,1,0,0);
    cx.fillStyle='rgba(0,0,0,.35)'; cx.fillRect(0,0,cv.width,cv.height);
    cx.fillStyle='#ffe66d'; cx.textAlign='center';
    cx.font='bold '+Math.floor(cv.width*0.16)+'px system-ui';
    cx.fillText('FINISH!',cv.width/2,cv.height*0.52);
  }
}

function loop(ts){
  if(!lastTs) lastTs=ts;
  const dt=Math.min(32,ts-lastTs); lastTs=ts;
  update(dt); draw();
  requestAnimationFrame(loop);
}

// ===== Result / Points =====
function awardPoints(){
  const award=[10,7,5,3,1];
  finishOrder.sort((a,b)=>a.tFinish-b.tFinish);
  finishOrder.forEach((b,i)=>{ totalPts[b.color]+= (award[i]||0); });
}
const resultView=document.getElementById('result');
const resultTitle=document.getElementById('resultTitle');
const resultTable=document.getElementById('resultTable');
const nextBtn=document.getElementById('nextBtn');
const restartBtn=document.getElementById('restartBtn');
nextBtn.onclick=()=>{ resultView.style.display='none'; raceNo++; document.getElementById('raceNum').textContent=raceNo; resetRace(); startCountdown(); };
restartBtn.onclick=()=>location.reload();

function showResult(){
  awardPoints();
  resultTable.innerHTML='';
  const trH=(h)=>{const tr=document.createElement('tr'); tr.innerHTML=h; return tr;};
  resultTable.appendChild(trH(`<td style="opacity:.8">順位</td><td>色</td><td style="text-align:right">Pt</td>`));
  const award=[10,7,5,3,1];
  finishOrder.forEach((b,i)=>resultTable.appendChild(trH(`<td style="text-align:right">${i+1}</td><td>${COLOR_JP[b.color]||b.color}</td><td style="text-align:right">${award[i]||0}</td>`)));

  if(raceNo<3){
    resultTitle.textContent=`RACE ${raceNo} 結果`;
    nextBtn.style.display='inline-block'; restartBtn.style.display='none';
  }else{
    resultTitle.textContent='最終結果';
    nextBtn.style.display='none'; restartBtn.style.display='inline-block';
    resultTable.appendChild(trH(`<td colspan="3" style="padding-top:8px"></td>`));
    resultTable.appendChild(trH(`<td style="opacity:.8">総合</td><td>色</td><td style="text-align:right">合計</td>`));
    Object.entries(totalPts).sort((a,b)=>b[1]-a[1]).forEach(([c,p],i)=>{
      resultTable.appendChild(trH(`<td style="text-align:right">${i+1}</td><td>${COLOR_JP[c]||c}</td><td style="text-align:right">${p}</td>`));
    });
  }
  resultView.style.display='flex';
}

// ===== Boot =====
function buildIfReady(){ if(img.hoke){ buildWallMask(); resetRace(); } }
(async function(){
  try{
    await loadAll();
    buildWallMask(); resetRace();
    document.getElementById('loading').style.display='none';
    requestAnimationFrame(loop);
  }catch(e){
    document.getElementById('loading').textContent='画像の読み込みに失敗しました。ファイル名と配置を確認してください。';
    console.error(e);
  }
})();
})();
</script>
</body>
</html>
