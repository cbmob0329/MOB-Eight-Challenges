<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>MOB Hockey (Solo / 2 Pucks / FX)</title>
<style>
  :root{ --hud:#0e0f12cc; --fg:#fff; --good:#34d399; --bad:#f87171; }
  html,body{margin:0;height:100%;background:#000;color:var(--fg);font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Sans","Yu Gothic",sans-serif}
  #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
  #cv{display:block;touch-action:none;background:#000; box-shadow:0 0 0 1px #171a22;}
  #hud{position:fixed;inset:0;pointer-events:none}
  .panel{position:fixed;left:0;right:0;display:flex;justify-content:center;gap:12px;pointer-events:none}
  .topbar{top:0;padding:env(safe-area-inset-top,10px) 10px 10px;align-items:center}
  .bottombar{bottom:0;padding:10px 10px env(safe-area-inset-bottom,10px);align-items:center}
  .pill{
    background:var(--hud);backdrop-filter:blur(6px);
    border:1px solid #2a2f3a; border-radius:999px; padding:8px 14px; font-weight:700; letter-spacing:.3px; display:flex; align-items:center; gap:10px
  }
  .sep{opacity:.35}
  .count{font-size:28px;min-width:2ch;text-align:center}
  #final{position:fixed; inset:0; background:#000a; display:none; align-items:center; justify-content:center; z-index:9; backdrop-filter:blur(2px)}
  #final .card{width:min(820px,92vw); background:#0c0f16; border:1px solid #242a36; border-radius:16px; padding:22px; box-shadow:0 10px 40px rgba(0,0,0,.5)}
  #final h3{margin:0 0 12px; font-size:28px}
  #final .big{font-size:18px; color:#cfe1ff; margin-bottom:10px}
  #final .grid{display:grid; grid-template-columns:auto 1fr auto; gap:12px; align-items:center}
  #final .rank{font-size:24px; font-weight:900; color:#fff}
  #final .name{font-size:24px; font-weight:800; color:#e8edf7}
  #final .pts{font-size:24px; font-weight:900; text-align:right}
  .btn{pointer-events:auto; user-select:none; cursor:pointer; padding:12px 18px; border-radius:14px; border:1px solid #323643; background:#151923; transition:.2s; color:#fff}
  .btn:hover{transform:translateY(-1px)}
</style>
</head>
<body>
  <div id="wrap">
    <canvas id="cv" width="900" height="900"></canvas>
    <div id="hud">
      <div class="panel topbar">
        <div class="pill">
          <span>TIME</span><span class="sep">|</span><span id="time" class="count">30.0</span>
          <span class="sep">|</span><span>YOU</span><b id="youPts" style="color:var(--good)">0</b>
        </div>
      </div>
      <div class="panel bottombar" style="justify-content:center">
        <div id="msg" class="pill" style="font-size:20px;">準備中…</div>
      </div>
    </div>
  </div>

  <div id="final">
    <div class="card">
      <h3>リザルト</h3>
      <div id="finalYou" class="big"></div>
      <div id="finalGrid" class="grid"></div>
      <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:16px">
        <button class="btn" onclick="location.reload()">もう一度</button>
      </div>
    </div>
  </div>

<script>
(()=>{'use strict';
  // ====== refs ======
  const canvas = document.getElementById('cv');
  const ctx = canvas.getContext('2d');
  const hudMsg = document.getElementById('msg');
  const timeEl = document.getElementById('time');
  const youPtsEl = document.getElementById('youPts');
  const finalEl = document.getElementById('final');
  const finalGrid = document.getElementById('finalGrid');
  const finalYou = document.getElementById('finalYou');

  // ====== config ======
  const GAME = {
    state:'init',
    length:30_000, startAt:0, now:0,
    size:900, lineY:450, wall:0,
    topGoal:{ x0:0.35, x1:0.65 },
    bottomGoal:{ x0:0.35, x1:0.65 },
    images:{}, assetsReady:false
  };

  function resizeSquare(){
    const s = Math.min(window.innerWidth, window.innerHeight);
    canvas.width = s; canvas.height = s;
    GAME.size = s; GAME.lineY = (s/2)|0;
    GAME.wall = Math.max(10, Math.round(s * 0.045));
    canvas.style.width = s+'px'; canvas.style.height = s+'px';
  }
  window.addEventListener('resize', resizeSquare, {passive:true});
  resizeSquare();

  // images (parallel; do not block)
  const IMG_LIST = {
    rink:'hokehai.png', smash:'smash.png',
    black:'black.png', blue:'blue.png', green:'green.png', mura:'mura.png',
    orange:'orange.png', pink:'pink.png', red:'red.png', yellow:'yellow.png'
  };
  function loadImage(src){ return new Promise(res=>{ const im=new Image(); im.onload=()=>res(im); im.onerror=()=>res(null); im.src=src+(src.includes('?')?'':'?v='+Date.now()); }); }
  (async()=>{ for (const [k,src] of Object.entries(IMG_LIST)){ GAME.images[k]=await loadImage(src); } GAME.assetsReady=true; })();

  // ====== parameters ======
  const P = {
    puckR: ()=>Math.max(16, GAME.size*0.055),   // さらに少し大きめ
    smashR: ()=>Math.max(26, GAME.size*0.038),
    maxSpd: ()=>Math.max(600, GAME.size*0.95),
    friction: 0.9935,
    hitBoostPlayer: 1.18,
    tiltAccel: ()=>GAME.size*0.020,            // 上半分にいるパックへ微小な下向き加速度
    minKick: ()=>GAME.size*0.08                // 停止回避の微小キック速度
  };

  // play area
  const xMin=()=>GAME.wall, xMax=()=>GAME.size-GAME.wall;
  const yMin=()=>GAME.wall, yMax=()=>GAME.size-GAME.wall;

  // colors
  const colorMap = { red:'#ef4444', blue:'#3b82f6', green:'#22c55e', mura:'#8b5cf6', orange:'#f59e0b', pink:'#ec4899', yellow:'#eab308', black:'#e5e7eb' };
  const colorOf = k => colorMap[k]||'#e5e7eb';

  // ====== center popup (goal FX) ======
  let popup = null; // {text, color, t, dur}
  function firePopup(text, color){
    popup = { text, color, t:0, dur:900 }; // ms
  }
  function drawPopup(dt){
    if (!popup) return;
    popup.t += dt*1000;
    const p = Math.min(1, popup.t/popup.dur);
    const alpha = 1 - p;
    const scale = 1 + 0.2*(1-p); // 少し縮みながら消える
    ctx.save();
    ctx.translate(GAME.size/2, GAME.size/2);
    ctx.scale(scale, scale);
    ctx.globalAlpha = alpha;
    // うっすら縁
    ctx.fillStyle = '#000a';
    ctx.fillRect(-150, -60, 300, 120);
    // テキスト
    ctx.fillStyle = popup.color;
    ctx.font = `700 ${Math.round(GAME.size*0.12)}px system-ui, sans-serif`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(popup.text, 0, 10);
    ctx.restore();
    if (popup.t>=popup.dur) popup=null;
  }

  // ====== entities ======
  class Puck{
    constructor(key, field){
      const xmin=xMin(), xmax=xMax();
      const yTop = (yMin()+GAME.lineY)/2, yBot = (yMax()+GAME.lineY)/2;
      this.key=key;
      this.x = xmin + (xmax-xmin)*(0.25 + 0.5*Math.random());
      this.y = field==='T'? yTop : yBot;
      this.vx = (Math.random()*2-1)*P.maxSpd()*0.20;
      this.vy = (Math.random()*2-1)*P.maxSpd()*0.20;
      this.r=P.puckR(); this.scored=false;
      this.spawning=false; // 天から降下中か
      this.blinkT=0;
    }
    spawnFromHeavenToCenter(){
      this.spawning = true;
      this.x = (xMin()+xMax())/2;
      this.y = yMin() - this.r - 6; // 壁の外から
      this.vx = 0; this.vy = P.maxSpd()*0.25; // 下方向に降下
      this.blinkT = 0;
    }
    step(dt){
      // 傾斜（上半分のみ下向き加速）
      if (!this.spawning && this.y < GAME.lineY){
        this.vy += P.tiltAccel()*dt;
        // ほぼ停止なら微小キック
        const spd = Math.hypot(this.vx, this.vy);
        if (spd < P.minKick()*0.2){
          this.vy += P.minKick()*0.6;
          this.vx += (Math.random()*2-1)*P.minKick()*0.15;
        }
      }

      this.x+=this.vx*dt; this.y+=this.vy*dt;
      if (!this.spawning){ this.vx*=P.friction; this.vy*=P.friction; }

      const xmin=xMin(), xmax=xMax(), ymin=yMin(), ymax=yMax();
      // side walls
      if (this.x < xmin + this.r){ this.x = xmin + this.r; this.vx = Math.abs(this.vx); }
      if (this.x > xmax - this.r){ this.x = xmax - this.r; this.vx = -Math.abs(this.vx); }

      // heaven降下中の停止条件（中央まで来たら通常化）
      if (this.spawning){
        this.blinkT += dt;
        const targetY = (yMin()+yMax())/2;
        if (this.y >= targetY){
          this.spawning = false;
          // センターで少しだけランダムに動き出す
          this.vx = (Math.random()*2-1)*P.maxSpd()*0.18;
          this.vy = (Math.random()*2-1)*P.maxSpd()*0.18;
          return;
        }
        return; // 壁・ゴール判定はスポーン完了後
      }

      // goals
      const gx0 = xmin + (xmax - xmin)*GAME.topGoal.x0;
      const gx1 = xmin + (xmax - xmin)*GAME.topGoal.x1;
      if (this.y < ymin + this.r){
        if (this.x>gx0 && this.x<gx1){ scoreGoal('TOP', this); this.scored=true; }
        else{ this.y = ymin + this.r; this.vy = Math.abs(this.vy); }
      }
      if (this.y > ymax - this.r){
        if (this.x>gx0 && this.x<gx1){ scoreGoal('BOTTOM', this); this.scored=true; }
        else{ this.y = ymax - this.r; this.vy = -Math.abs(this.vy); }
      }
    }
    draw(){
      const im=GAME.images[this.key], s=this.r*2;
      if (this.spawning){
        // 点滅（blinkTで0.1s周期に）
        const on = (Math.floor(this.blinkT*10)%2)===0;
        if (!on) return;
      }
      if (im) ctx.drawImage(im, this.x-this.r, this.y-this.r, s, s);
      else { ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fillStyle=colorOf(this.key); ctx.fill(); }
    }
  }

  class Smasher{
    constructor(){
      this.r=P.smashR();
      this.x=(xMin()+xMax())/2;
      this.y=(GAME.lineY + yMax())/2;
      this.vx=this.vy=0; this.targetX=this.x; this.targetY=this.y;
      this.lastX=this.x; this.lastY=this.y;
    }
    clamp(){
      const m=this.r+2, xmin=xMin()+m, xmax=xMax()-m;
      const yminH=GAME.lineY+m, ymaxH=yMax()-m;
      this.x=Math.max(xmin,Math.min(xmax,this.x));
      this.y=Math.max(yminH,Math.min(ymaxH,this.y));
    }
    setTarget(x,y){ this.targetX=x; this.targetY=y; }
    step(dt){
      const spd=P.maxSpd()*1.9;
      const dx=this.targetX-this.x, dy=this.targetY-this.y, d=Math.hypot(dx,dy);
      const mv=spd*dt; this.lastX=this.x; this.lastY=this.y;
      if (d<=mv){ this.x=this.targetX; this.y=this.targetY; }
      else{ this.x+=dx/d*mv; this.y+=dy/d*mv; }
      this.clamp(); this.vx=(this.x-this.lastX)/dt; this.vy=(this.y-this.lastY)/dt;
    }
    draw(){
      const im=GAME.images.smash, R=this.r;
      if (im) ctx.drawImage(im, this.x-R, this.y-R, R*2, R*2);
      else { ctx.beginPath(); ctx.arc(this.x,this.y,R,0,Math.PI*2); ctx.fillStyle='#ef4444'; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='#fff2'; ctx.stroke(); }
    }
  }

  // ====== world ======
  let pucks=[];
  const player=new Smasher();
  let score={ YOU:0 };

  function spawnPucks(){
    pucks=[];
    const others=['black','blue','green','mura','orange','pink','yellow'];
    const rnd=others[(Math.random()*others.length)|0];
    pucks.push(new Puck('red','B'));
    pucks.push(new Puck(rnd,'T'));
  }

  // ====== scoring ======
  function scoreGoal(side, puck){
    if (side==='TOP'){ score.YOU += 3; firePopup('+3', '#34d399'); }
    else{ score.YOU -= 1; firePopup('-1', '#f87171'); }
    youPtsEl.textContent = score.YOU|0;

    // スコアに使ったパックを「天からスポーン」
    const np = new Puck(puck.key, 'T'); // 仮
    np.spawnFromHeavenToCenter();
    pucks.push(np);
  }

  // ====== collisions ======
  // Smasher vs Puck
  function collideSmasher(){
    for (const puck of pucks){
      if (puck.spawning) continue;
      const dx=puck.x-player.x, dy=puck.y-player.y, rr=(puck.r+player.r);
      if (dx*dx+dy*dy<=rr*rr){
        const d=Math.hypot(dx,dy)||1, nx=dx/d, ny=dy/d;
        const swing=Math.hypot(player.vx,player.vy);
        const impulse=Math.min(P.maxSpd(), 260 + swing*1.0)*P.hitBoostPlayer;
        puck.vx=nx*impulse; puck.vy=ny*impulse;
        const overlap=rr-d+0.5; puck.x+=nx*overlap; puck.y+=ny*overlap;
      }
    }
  }
  // Puck vs Puck（簡易弾性）
  function collidePucks(){
    for (let i=0;i<pucks.length;i++){
      const a=pucks[i]; if (a.spawning) continue;
      for (let j=i+1;j<pucks.length;j++){
        const b=pucks[j]; if (b.spawning) continue;
        const dx=b.x-a.x, dy=b.y-a.y;
        const rr = (a.r+b.r);
        const distSq = dx*dx+dy*dy;
        if (distSq <= rr*rr){
          const dist = Math.sqrt(distSq)||1;
          const nx = dx/dist, ny=dy/dist;
          // 速度成分の交換（法線方向）
          const va = a.vx*nx + a.vy*ny;
          const vb = b.vx*nx + b.vy*ny;
          const diff = vb - va;
          a.vx += nx*diff; a.vy += ny*diff;
          b.vx -= nx*diff; b.vy -= ny*diff;
          // めり込み解消
          const overlap = rr - dist + 0.5;
          a.x -= nx*overlap*0.5; a.y -= ny*overlap*0.5;
          b.x += nx*overlap*0.5; b.y += ny*overlap*0.5;
        }
      }
    }
  }

  // ====== input ======
  let dragging=false;
  function toCanvasXY(e){
    const r=canvas.getBoundingClientRect();
    const x=((e.touches?e.touches[0].clientX:e.clientX)-r.left)*(canvas.width/r.width);
    const y=((e.touches?e.touches[0].clientY:e.clientY)-r.top )*(canvas.height/r.height);
    return {x,y};
  }
  function onDown(e){ dragging=true; const {x,y}=toCanvasXY(e); player.setTarget(x,y); e.preventDefault(); }
  function onMove(e){ const {x,y}=toCanvasXY(e); if (dragging) player.setTarget(x,y); e.preventDefault(); }
  function onUp(){ dragging=false; }
  canvas.addEventListener('mousedown', onDown);
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
  canvas.addEventListener('touchstart', onDown, {passive:false});
  window.addEventListener('touchmove', onMove, {passive:false});
  window.addEventListener('touchend', onUp);

  // ====== CPUs（裏で進行、結果のみ表示） ======
  const CPU=[{name:'ブラック'},{name:'ブルー'},{name:'グリーン'},{name:'パープル'},{name:'オレンジ'},{name:'ピンク'},{name:'イエロー'}];
  const cpuScores=Object.fromEntries(CPU.map(c=>[c.name,0]));
  function cpuTick(){ const name=CPU[(Math.random()*CPU.length)|0].name; Math.random()<0.72 ? (cpuScores[name]+=3) : (cpuScores[name]-=1); }

  // ====== background (rink+walls+line) ======
  function drawBackground(){
    const S=GAME.size, xmin=xMin(), xmax=xMax(), ymin=yMin(), ymax=yMax();
    ctx.clearRect(0,0,S,S);
    const im=GAME.images.rink;
    if (im){
      const iw=im.naturalWidth||1280, ih=im.naturalHeight||720, r=iw/ih;
      let dw,dh; if (r>1){ dh=S; dw=dh*r; } else { dw=S; dh=dw/r; }
      const dx=(S-dw)/2, dy=(S-dh)/2; ctx.drawImage(im, dx, dy, dw, dh);
    }else{ ctx.fillStyle='#0b0e14'; ctx.fillRect(0,0,S,S); }
    ctx.fillStyle='#111a';
    const gx0 = xmin + (xmax - xmin)*GAME.topGoal.x0, gx1 = xmin + (xmax - xmin)*GAME.topGoal.x1;
    ctx.fillRect(xmin, ymin - GAME.wall, gx0 - xmin, GAME.wall);
    ctx.fillRect(gx1, ymin - GAME.wall, xmax - gx1, GAME.wall);
    ctx.fillRect(xmin, ymax, gx0 - xmin, GAME.wall);
    ctx.fillRect(gx1, ymax, xmax - gx1, GAME.wall);
    ctx.fillRect(xmin - GAME.wall, ymin - GAME.wall, GAME.wall, (ymax - ymin) + GAME.wall*2);
    ctx.fillRect(xmax, ymin - GAME.wall, GAME.wall, (ymax - ymin) + GAME.wall*2);
    ctx.strokeStyle='rgba(255,255,255,0.7)'; ctx.lineWidth=Math.max(2,S*0.006); ctx.setLineDash([14,14]);
    ctx.beginPath(); ctx.moveTo(xmin, GAME.lineY); ctx.lineTo(xmax, GAME.lineY); ctx.stroke(); ctx.setLineDash([]);
  }

  // ====== loop & states ======
  let popupDtAccum = 0;
  let rafStarted=false; function safeRAF(){ if(!rafStarted){ rafStarted=true; requestAnimationFrame(loop); } }
  function startCountdown(){ GAME.state='countdown'; GAME.startAt=performance.now(); hudMsg.style.color='#e5e7eb'; hudMsg.textContent='3'; safeRAF(); }
  function endGame(){
    GAME.state='ended'; hudMsg.textContent='FINISH!';
    const rows=[{name:'YOU', pts:score.YOU}]; for (const c of CPU) rows.push({name:c.name, pts:cpuScores[c.name]});
    rows.sort((a,b)=>b.pts-a.pts);
    finalGrid.innerHTML = rows.map((r,i)=>`<div class="rank">${i+1}</div><div class="name" style="color:${r.name==='YOU'?'#fff':'#e8edf7'}">${r.name}</div><div class="pts" style="color:${r.name==='YOU'?'#34d399':'#e8edf7'}">${r.pts|0}</div>`).join('');
    finalYou.textContent = `あなたのスコア： ${score.YOU|0} 点（ゴール+3 / 失点-1）`;
    finalEl.style.display='flex';
  }

  let lastT=performance.now(), cpuNext=lastT+300;
  function loop(t){
    GAME.now=t;
    const dt=Math.min(0.033, (t-lastT)/1000); lastT=t;

    if (GAME.state==='countdown'){
      const elapsed=t-GAME.startAt, total=3200;
      drawBackground();
      const left=Math.max(0,total-elapsed);
      if (left<=0){
        spawnPucks(); youPtsEl.textContent='0';
        GAME.state='playing'; GAME.startAt=t; hudMsg.textContent='GO!'; hudMsg.style.color='#34d399';
        popup=null;
      }else{
        const step=Math.ceil(left/800); hudMsg.textContent = (step>=2)? String(step-1) : 'GO!';
      }
      requestAnimationFrame(loop); return;
    }

    if (GAME.state==='playing'){
      const remain=Math.max(0, GAME.length - (t-GAME.startAt));
      timeEl.textContent=(remain/1000).toFixed(1);

      // physics
      player.step(dt);
      for (const p of pucks){ p.r=P.puckR(); p.step(dt); }
      collideSmasher();
      collidePucks();
      pucks=pucks.filter(p=>!p.scored);

      // CPUs
      if (t>=cpuNext){ cpuTick(); cpuNext=t+300; }

      // draw
      drawBackground();
      for (const p of pucks) p.draw();
      player.draw();
      drawPopup(dt);

      if (remain<=0){ endGame(); return; }
      requestAnimationFrame(loop); return;
    }

    if (GAME.state==='ended'){ drawBackground(); for (const p of pucks) p.draw(); player.draw(); drawPopup(dt); return; }
  }

  // start now
  startCountdown();
  setTimeout(()=>{ if (GAME.state==='init') startCountdown(); }, 300);
  setTimeout(safeRAF, 50);

})();
</script>
</body>
</html>
