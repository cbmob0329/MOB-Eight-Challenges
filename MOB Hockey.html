<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>MOB Hockey (Square / 4 Pucks)</title>
<style>
  :root{
    --hud:#0e0f12cc; --fg:#fff; --accent:#13c4ff; --good:#34d399; --bad:#f87171;
  }
  html,body{margin:0;height:100%;background:#000;color:var(--fg);font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Sans","Yu Gothic",sans-serif}
  #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
  #cv{display:block;touch-action:none;background:#000; box-shadow:0 0 0 1px #171a22;}
  #hud{position:fixed;inset:0;pointer-events:none}
  .panel{position:fixed;left:0;right:0;display:flex;justify-content:center;gap:12px;pointer-events:none}
  .topbar{top:0;padding:env(safe-area-inset-top,10px) 10px 10px;align-items:center}
  .bottombar{bottom:0;padding:10px 10px env(safe-area-inset-bottom,10px);align-items:center}
  .pill{
    background:var(--hud);backdrop-filter:blur(6px);
    border:1px solid #2a2f3a; border-radius:999px; padding:8px 14px; font-weight:700; letter-spacing:.3px; display:flex; align-items:center; gap:10px
  }
  .sep{opacity:.35}
  .count{font-size:28px;min-width:2ch;text-align:center}
  #final{
    position:fixed; inset:0; background:#000a; display:none; align-items:center; justify-content:center; z-index:9; backdrop-filter:blur(2px)
  }
  #final .card{
    width:min(820px,92vw); background:#0c0f16; border:1px solid #242a36; border-radius:16px; padding:22px; box-shadow:0 10px 40px rgba(0,0,0,.5)
  }
  #final h3{margin:0 0 12px; font-size:28px}
  #final .big{font-size:18px; color:#cfe1ff; margin-bottom:10px}
  #final .grid{display:grid; grid-template-columns:auto 1fr auto; gap:12px; align-items:center}
  #final .rank{font-size:24px; font-weight:900; color:#fff}
  #final .name{font-size:24px; font-weight:800; color:#e8edf7}
  #final .pts{font-size:24px; font-weight:900; text-align:right}
  .btn{pointer-events:auto; user-select:none; cursor:pointer; padding:12px 18px; border-radius:14px; border:1px solid #323643; background:#151923; transition:.2s; color:#fff}
  .btn:hover{transform:translateY(-1px)}
</style>
</head>
<body>
  <div id="wrap">
    <canvas id="cv" width="900" height="900"></canvas>
    <div id="hud">
      <div class="panel topbar">
        <div class="pill">
          <span>TIME</span><span class="sep">|</span><span id="time" class="count">30.0</span>
          <span class="sep">|</span><span>YOU</span><b id="youPts" style="color:var(--good)">0</b>
          <span class="sep">/</span><span>DEALER</span><b id="aiPts" style="color:var(--good)">0</b>
        </div>
      </div>
      <div class="panel bottombar" style="justify-content:center">
        <div id="msg" class="pill" style="font-size:20px;">準備中…</div>
      </div>
    </div>
  </div>

  <div id="final">
    <div class="card">
      <h3>リザルト</h3>
      <div id="finalYou" class="big"></div>
      <div id="finalGrid" class="grid"></div>
      <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:16px">
        <button class="btn" onclick="location.reload()">もう一度</button>
      </div>
    </div>
  </div>

<script>
(()=>{
  // ====== 基本参照 ======
  const canvas = document.getElementById('cv');
  const ctx = canvas.getContext('2d');
  const hudMsg = document.getElementById('msg');
  const timeEl = document.getElementById('time');
  const youPtsEl = document.getElementById('youPts');
  const aiPtsEl = document.getElementById('aiPts');
  const finalEl = document.getElementById('final');
  const finalGrid = document.getElementById('finalGrid');
  const finalYou = document.getElementById('finalYou');

  // ====== ゲーム設定（正方形 / 銀の部分から壁） ======
  const GAME = {
    state:'loading', // 'countdown' | 'playing' | 'ended'
    length:30_000, // 30s
    startAt:0, now:0,
    size:900, // キャンバスの基準サイズ（resizeで更新）
    lineY:450, // 中央水平ライン（上=ディーラー陣 / 下=プレイヤー陣）
    wall:0,    // 壁の厚さ（銀フレームの内側）※resizeで算出
    topGoal:{ x0:0.35, x1:0.65 },     // 上ゴール：上壁の開口（割合）
    bottomGoal:{ x0:0.35, x1:0.65 },  // 下ゴール：下壁の開口（割合）
    images:{}, assetsReady:false
  };

  // ====== 正方形リサイズ ======
  function resizeSquare(){
    const w = window.innerWidth, h = window.innerHeight;
    const s = Math.min(w, h); // 常に正方形
    canvas.width = s; canvas.height = s;
    GAME.size = s; GAME.lineY = (s/2)|0;
    // “銀の部分から壁”想定：フレームの厚みをサイズ比で確保（見た目に寄せて約4.5%）
    GAME.wall = Math.max(10, Math.round(s * 0.045));
    canvas.style.width = s+'px';
    canvas.style.height = s+'px';
  }
  window.addEventListener('resize', resizeSquare, {passive:true});
  resizeSquare();

  // ====== 画像ロード（未読でも進行） ======
  const IMG_LIST = {
    rink:'hokehai.png',
    smash:'smash.png',
    black:'black.png', blue:'blue.png', green:'green.png', mura:'mura.png',
    orange:'orange.png', pink:'pink.png', red:'red.png', yellow:'yellow.png'
  };
  function loadImage(src){
    return new Promise(res=>{
      const im = new Image();
      im.onload = ()=>res(im);
      im.onerror = ()=>res(null);
      im.src = src + (src.includes('?')?'':'?v=' + Date.now());
    });
  }
  (async()=>{
    for (const [k,src] of Object.entries(IMG_LIST)){
      GAME.images[k] = await loadImage(src);
    }
    GAME.assetsReady = true;
    startCountdown();
  })();

  // ====== パラメータ（感度アップ） ======
  const P = {
    puckR: ()=>Math.max(10, GAME.size*0.022),
    smashR: ()=>Math.max(26, GAME.size*0.038),
    maxSpd: ()=>Math.max(600, GAME.size*0.95),   // 速度アップ
    friction: 0.994,
    hitBoost: 1.12                                   // 当たりの伸び少し強化
  };

  // ====== プレイ可能域（壁から内側） ======
  function playMinX(){ return GAME.wall; }
  function playMaxX(){ return GAME.size - GAME.wall; }
  function playMinY(){ return GAME.wall; }
  function playMaxY(){ return GAME.size - GAME.wall; }

  // ====== エンティティ ======
  const colorMap = {
    red:'#ef4444', blue:'#3b82f6', green:'#22c55e', mura:'#8b5cf6',
    orange:'#f59e0b', pink:'#ec4899', yellow:'#eab308', black:'#e5e7eb'
  };
  function colorOf(key){ return colorMap[key] || '#e5e7eb'; }

  class Puck{
    constructor(colorKey, field){ // field: 'T' (上) or 'B' (下)
      this.key = colorKey;
      const x0 = playMinX(), x1 = playMaxX();
      const yTop = (playMinY()+GAME.lineY)/2;
      const yBot = (playMaxY()+GAME.lineY)/2;
      this.x = x0 + (x1-x0)*(0.2 + 0.6*Math.random());
      this.y = field==='T'? yTop : yBot;
      this.vx = (Math.random()*2-1)*P.maxSpd()*0.25;
      this.vy = (Math.random()*2-1)*P.maxSpd()*0.25;
      this.r = P.puckR();
      this.scored = false;
    }
    step(dt){
      this.x += this.vx*dt; this.y += this.vy*dt;
      this.vx *= P.friction; this.vy *= P.friction;

      const xmin = playMinX(), xmax = playMaxX();
      const ymin = playMinY(), ymax = playMaxY();

      // 左右壁に反射
      if (this.x < xmin + this.r){ this.x = xmin + this.r; this.vx = Math.abs(this.vx); }
      if (this.x > xmax - this.r){ this.x = xmax - this.r; this.vx = -Math.abs(this.vx); }

      // 上壁/下壁はゴール開口チェック優先（開口は壁内側のライン上）
      const gx0 = xmin + (xmax - xmin)*GAME.topGoal.x0;
      const gx1 = xmin + (xmax - xmin)*GAME.topGoal.x1;

      // 上ゴール（y < ymin + r）
      if (this.y < ymin + this.r){
        if (this.x>gx0 && this.x<gx1){
          scoreGoal('TOP', this);
          this.scored = true;
        }else{
          this.y = ymin + this.r; this.vy = Math.abs(this.vy);
        }
      }
      // 下ゴール
      if (this.y > ymax - this.r){
        if (this.x>gx0 && this.x<gx1){
          scoreGoal('BOTTOM', this);
          this.scored = true;
        }else{
          this.y = ymax - this.r; this.vy = -Math.abs(this.vy);
        }
      }
    }
    draw(){
      const im = GAME.images[this.key];
      if (im){
        const size = this.r*2;
        ctx.drawImage(im, this.x-this.r, this.y-this.r, size, size);
      }else{
        ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
        ctx.fillStyle = colorOf(this.key); ctx.fill();
      }
    }
  }

  class Smasher{
    constructor(half, name, color){
      this.half = half; // 'B'(下=プレイヤー) / 'T'(上=ディーラー)
      this.name = name; this.color = color;
      this.r = P.smashR();
      this.x = (playMinX()+playMaxX())/2;
      this.y = half==='B'? (GAME.lineY + playMaxY())/2 : (playMinY() + GAME.lineY)/2;
      this.vx = 0; this.vy = 0;
      this.targetX = this.x; this.targetY = this.y;
      this.lastX = this.x; this.lastY = this.y;
    }
    clampToHalf(){
      const m = this.r+2;
      const xmin = playMinX()+m, xmax = playMaxX()-m;
      const yminH = this.half==='B'? GAME.lineY + m : playMinY()+m;
      const ymaxH = this.half==='B'? playMaxY()-m : GAME.lineY - m;
      this.x = Math.max(xmin, Math.min(xmax, this.x));
      this.y = Math.max(yminH, Math.min(ymaxH, this.y));
    }
    setTarget(x,y){ this.targetX=x; this.targetY=y; }
    step(dt, fast=false){
      // 感度アップ：速度上限↑、プレイヤーは追従を鋭く
      const base = P.maxSpd();
      const spd = fast ? base*1.6 : base*1.15; // プレイヤー：1.6 / AI：1.15
      const dx = this.targetX - this.x, dy = this.targetY - this.y;
      const d = Math.hypot(dx,dy);
      const maxMove = spd*dt;
      this.lastX = this.x; this.lastY = this.y;
      if (d <= maxMove){ this.x = this.targetX; this.y = this.targetY; }
      else{ this.x += dx/d*maxMove; this.y += dy/d*maxMove; }
      this.clampToHalf();
      this.vx = (this.x - this.lastX)/dt;
      this.vy = (this.y - this.lastY)/dt;
    }
    draw(){
      const im = GAME.images.smash;
      const R = this.r;
      if (im){
        ctx.drawImage(im, this.x-R, this.y-R, R*2, R*2);
      }else{
        ctx.beginPath(); ctx.arc(this.x,this.y,R,0,Math.PI*2);
        ctx.fillStyle = this.color; ctx.fill();
        ctx.lineWidth = 2; ctx.strokeStyle = '#fff2'; ctx.stroke();
      }
    }
  }

  // ====== ゲーム体 ======
  let pucks = [];
  const player = new Smasher('B','YOU', colorMap.red);
  const dealer = new Smasher('T','DEALER', colorMap.blue);
  let score = { YOU:0, DEALER:0 };

  // 4パック（赤＋ランダム3色）
  function spawnPucks(){
    pucks = [];
    const all = ['black','blue','green','mura','orange','pink','yellow'];
    // ランダム3色（重複なし）
    for (let i=all.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [all[i],all[j]]=[all[j],all[i]]; }
    const picks = ['red', all[0], all[1], all[2]];

    // 配置：上下に2個ずつ（見やすさ＆バランス）
    const fields = ['B','B','T','T'];
    // シャッフルして割当て
    for (let i=fields.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [fields[i],fields[j]]=[fields[j],fields[i]]; }
    for (let k=0;k<4;k++){
      pucks.push( new Puck(picks[k], fields[k]) );
    }
  }

  // ====== 得点処理（上下ゴール） ======
  function scoreGoal(side, puck){
    const isRed = (puck.key==='red');
    const isBlue = (puck.key==='blue');
    if (side==='TOP'){
      // 上ゴール = ディーラーに失点 / プレイヤーに加点
      score.YOU += isRed ? 10 : 2;
      score.DEALER += isRed ? -5 : -1;
      flashMsg(isRed?'+10 (自色)':' +2', 'good');
    }else{ // BOTTOM
      // 下ゴール = プレイヤーに失点 / ディーラーに加点
      score.DEALER += isBlue ? 10 : 2;
      score.YOU += isRed ? -5 : -1;
      flashMsg(isRed?' -5 (自色失点)':' -1 (失点)','bad');
    }
    youPtsEl.textContent = score.YOU|0;
    aiPtsEl.textContent = score.DEALER|0;

    // 再投入：入れられた側の陣に1つだけ再スポーン（向きを反対へ）
    const field = (side==='TOP') ? 'T' : 'B';
    const np = new Puck(puck.key, field);
    np.vy = (side==='TOP'? 1 : -1) * P.maxSpd()*0.55;
    np.vx = (Math.random()*2-1)*P.maxSpd()*0.25;
    pucks.push(np);
  }

  // ====== 衝突（スマッシャー×パック） ======
  function collide(){
    for (const puck of pucks){
      for (const S of [player,dealer]){
        const dx = puck.x - S.x, dy = puck.y - S.y;
        const rr = (puck.r + S.r);
        if (dx*dx + dy*dy <= rr*rr){
          const dist = Math.hypot(dx,dy)||1;
          const nx = dx/dist, ny = dy/dist;
          const swing = Math.hypot(S.vx,S.vy);
          const impulse = Math.min(P.maxSpd(), 260 + swing*0.9) * P.hitBoost;
          puck.vx = nx*impulse; puck.vy = ny*impulse;
          const overlap = rr - dist + 0.5;
          puck.x += nx*overlap; puck.y += ny*overlap;
        }
      }
    }
  }

  // ====== ディーラーAI（上半分でプレイ） ======
  function aiStep(dt){
    let best=null, bestScore=-1e9;
    for (const p of pucks){
      if (p.y <= GAME.lineY){ // 上陣パック
        // 上壁方向＆中央寄りを評価。壁内側(ymin)に近いほど高評価
        const ymin = playMinY();
        const s = (p.y - ymin) * -1 - Math.abs(p.x - (playMinX()+playMaxX())/2)*0.35;
        if (s>bestScore){bestScore=s; best=p;}
      }
    }
    if (best){
      const tx = best.x + (Math.random()*2-1)*best.r*0.4;
      const ty = Math.min(GAME.lineY - dealer.r - 2, best.y - best.r*0.35);
      dealer.setTarget(tx,ty);
    }else{
      dealer.setTarget((playMinX()+playMaxX())/2, (playMinY()+GAME.lineY)/2);
    }
  }

  // ====== 入力（ドラッグ／タッチ：高感度） ======
  let dragging = false;
  function toCanvasXY(e){
    const rect = canvas.getBoundingClientRect();
    const x = ( (e.touches?e.touches[0].clientX:e.clientX) - rect.left ) * (canvas.width/rect.width);
    const y = ( (e.touches?e.touches[0].clientY:e.clientY) - rect.top ) * (canvas.height/rect.height);
    return {x,y};
  }
  function onDown(e){
    dragging = true; const {x,y} = toCanvasXY(e);
    player.setTarget(x,y);
    e.preventDefault();
  }
  function onMove(e){
    const {x,y} = toCanvasXY(e);
    if (dragging) player.setTarget(x,y);
    e.preventDefault();
  }
  function onUp(){ dragging=false; }
  canvas.addEventListener('mousedown', onDown);
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
  canvas.addEventListener('touchstart', onDown, {passive:false});
  window.addEventListener('touchmove', onMove, {passive:false});
  window.addEventListener('touchend', onUp);

  // ====== 背面CPU（別卓）※試合中は非表示、スコアのみ結果に反映 ======
  const CPU = [
    {name:'ブラック', color:'#111'}, {name:'ブルー', color:colorMap.blue},
    {name:'グリーン', color:colorMap.green}, {name:'パープル', color:colorMap.mura},
    {name:'オレンジ', color:colorMap.orange}, {name:'ピンク', color:colorMap.pink},
    {name:'イエロー', color:colorMap.yellow},
  ];
  const cpuScores = Object.fromEntries(CPU.map(c=>[c.name,0]));
  function cpuBackgroundTick(dt){
    const now = GAME.now;
    if (!cpuBackgroundTick.next) cpuBackgroundTick.next = now + 250;
    if (now >= cpuBackgroundTick.next){
      cpuBackgroundTick.next = now + 250; // 0.25sごと
      const pick = CPU[Math.random()*CPU.length|0].name;
      const r = Math.random();
      if (r < 0.60) cpuScores[pick] += 2;
      else if (r < 0.75) cpuScores[pick] += 10;
      else if (r < 0.93) cpuScores[pick] += -1;
      else cpuScores[pick] += -5;
    }
  }

  // ====== 背景描画（hokehai.png：正方形内 contain）＋壁・ライン・ゴール ======
  function drawBackground(){
    const S = GAME.size;
    const xmin = playMinX(), xmax = playMaxX();
    const ymin = playMinY(), ymax = playMaxY();
    ctx.clearRect(0,0,S,S);
    const im = GAME.images.rink;
    if (im){
      const iw = im.naturalWidth||1280, ih = im.naturalHeight||720;
      const imgRatio = iw/ih;
      let dw, dh;
      if (imgRatio > 1){ dh = S; dw = dh*imgRatio; } else { dw = S; dh = dw/imgRatio; }
      const dx = (S - dw)/2, dy = (S - dh)/2;
      ctx.drawImage(im, dx, dy, dw, dh);
    }else{
      ctx.fillStyle = '#0b0e14'; ctx.fillRect(0,0,S,S);
    }

    // 四方の壁（銀の部分から＝フレーム部分を壁として描く／開口は中央）
    ctx.fillStyle = '#111a';
    // 上壁（中央開口を除く）
    const gx0 = xmin + (xmax - xmin)*GAME.topGoal.x0;
    const gx1 = xmin + (xmax - xmin)*GAME.topGoal.x1;
    ctx.fillRect(xmin, ymin - GAME.wall, gx0 - xmin, GAME.wall); // 左側上壁
    ctx.fillRect(gx1, ymin - GAME.wall, xmax - gx1, GAME.wall);  // 右側上壁
    // 下壁
    ctx.fillRect(xmin, ymax, gx0 - xmin, GAME.wall);
    ctx.fillRect(gx1, ymax, xmax - gx1, GAME.wall);
    // 左右壁（全域）
    ctx.fillRect(xmin - GAME.wall, ymin - GAME.wall, GAME.wall, (ymax - ymin) + GAME.wall*2);
    ctx.fillRect(xmax, ymin - GAME.wall, GAME.wall, (ymax - ymin) + GAME.wall*2);

    // 中央ライン（水平）
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = Math.max(2, S*0.006);
    ctx.setLineDash([14,14]);
    ctx.beginPath(); ctx.moveTo(xmin, GAME.lineY); ctx.lineTo(xmax, GAME.lineY); ctx.stroke();
    ctx.setLineDash([]);
  }

  // ====== 画面メッセージ ======
  let flashTimer=0;
  function flashMsg(text, kind='good'){
    hudMsg.textContent = text;
    hudMsg.style.color = (kind==='good')? '#34d399' : '#f87171';
    flashTimer = 700;
  }

  // ====== ループ管理 ======
  function startCountdown(){
    GAME.state = 'countdown';
    GAME.startAt = performance.now();
    hudMsg.style.color = '#e5e7eb';
    requestAnimationFrame(loop);
  }

  function endGame(){
    GAME.state = 'ended';
    hudMsg.textContent = 'FINISH!';
    finalRender();
    finalEl.style.display = 'flex';
  }

  function finalRender(){
    // YOU / DEALER / CPU7 の9名で順位（試合中は非表示だったものをここで集計表示）
    const rows = [];
    rows.push({name:'YOU', pts:score.YOU, color:colorMap.red});
    rows.push({name:'DEALER', pts:score.DEALER, color:colorMap.blue});
    for (const c of CPU) rows.push({name:c.name, pts:cpuScores[c.name], color:c.color});
    rows.sort((a,b)=>b.pts - a.pts);

    finalGrid.innerHTML = rows.map((r,i)=>`
      <div class="rank">${i+1}</div>
      <div class="name" style="color:${r.name==='YOU'?'#fff':(r.name==='DEALER'?'#cde7ff':'#e8edf7')}">${r.name}</div>
      <div class="pts" style="color:${r.name==='YOU'?'#34d399':'#e8edf7'}">${r.pts|0}</div>
    `).join('');
    finalYou.textContent = `あなたのスコア： ${score.YOU|0} 点（赤+10 / 他色+2 / 失点-1 / 自色失点-5）`;
  }

  let lastT = performance.now();
  function loop(t){
    GAME.now = t;
    const dt = Math.min(0.033, (t - lastT)/1000);
    lastT = t;

    if (GAME.state==='countdown'){
      const elapsed = t - GAME.startAt;
      const total = 3200; // 3.2s（3→2→1→GO!）
      drawBackground();
      const left = Math.max(0,total - elapsed);
      if (left <= 0){
        spawnPucks();
        youPtsEl.textContent = '0'; aiPtsEl.textContent = '0';
        GAME.state = 'playing';
        GAME.startAt = t;
        hudMsg.textContent = 'GO!';
        hudMsg.style.color = '#34d399';
        flashTimer = 700;
      }else{
        const step = Math.ceil(left/800); // 4..1
        const label = step>=2 ? String(step-1) : 'GO!';
        hudMsg.textContent = label;
      }
      requestAnimationFrame(loop);
      return;
    }

    if (GAME.state==='playing'){
      const remain = Math.max(0, GAME.length - (t - GAME.startAt));
      timeEl.textContent = (remain/1000).toFixed(1);

      // 入力/AI/物理（プレイヤーは高感度モード）
      player.step(dt, true); aiStep(dt); dealer.step(dt, false);
      for (const p of pucks){ p.r = P.puckR(); p.step(dt); }
      collide();
      pucks = pucks.filter(p=>!p.scored);

      // 背面CPU（スコアだけ進める）
      cpuBackgroundTick(dt);

      // 描画
      drawBackground();
      for (const p of pucks) p.draw();
      player.draw(); dealer.draw();

      if (flashTimer>0){ flashTimer -= dt*1000; if (flashTimer<=0) hudMsg.textContent=''; }

      if (remain<=0){ endGame(); return; }
      requestAnimationFrame(loop);
      return;
    }

    if (GAME.state==='ended'){
      // 静止画描画
      drawBackground();
      for (const p of pucks) p.draw();
      player.draw(); dealer.draw();
      return;
    }
  }

})();
</script>
</body>
</html>
